(.nif24)
(.vendor "Nifler")
(.dialect "nim-parsed")
0,10,/Users/rumpf/projects/nim/compiler/vm.nim(stmts
 (comment),3(import
 7 semmacrosanity
),4(import
 5,1(infix / ~3 std 1(bracketConstr
 1 strutils 11 tables 19 parseutils
))2,2 msgs 8,2 vmdef 15,2 vmgen 22,2 nimsets 31,2 types 2,3 parser 10,3 vmdeps 18,3 idents 26,3 trees 33,3 renderer 43,3 options 52,3 transf 2,4 gorgeimpl 13,4 lineinfos 24,4 btrees 32,4 macrocacheimpl 2,5 modulegraphs 16,5 sighashes 27,5 int128 35,5 vmprofiler
),11(when
 5(elif
 7(call ~7 defined 1 nimPreviewSlimSystem)~3,1(stmts
 (import 10(infix
 / ~3 std 1 formatfloat
))
)
)
),13(importExcept 7 ast 18 getstr),14(from
 5 semfold 20 leValueConv 33 ordinalValToString
),15(from 5 evaltempl 22 evalTemplate),16(from
 5 magicsys 21 getSysType
)2,19(const
 traceCode . . . 19(call ~7 defined 1 nimVMDebug)
),21(when 5(elif
 hasFFI ~3,1(stmts (import 7 evalffi))
)),25(proc
 5 stackTraceAux . . . 18(params
 . 1(param
 c . . 3 PCtx .
)10(param x . . 3 PStackFrame .)26(param
 pc . . 4 int .
)35(param recursionLimit . . . 15 +100)
). . 2,1(stmts
 (if
 3(elif
 2(infix != ~2 x 3(nil))~1,1(stmts
 (if
 3(elif
 15(infix
 == ~15 recursionLimit 3 +0
)~1,1(stmts
 4(var calls . . . 8 +0)4,1(var x . . . 4 x),2(while
 8(infix
 != ~2 x 3(nil)
)2,1(stmts (cmd inc 4 calls)2,1(asgn
 ~2 x 3(dot ~1 x 1 next)
))
)10,5(call
 ~10 msgWriteln 2(dot ~1 c 1 config)18(infix & ~7(prefix
 $ 1 calls
)2" calls omitted
")40(curlyConstr
 1 msgNoUnitSep
)
),6(ret .)
)
)
)13,8(call
 ~13 stackTraceAux 1 c 5(dot ~1 x 1 next)13(dot
 ~1 x 1 comesFrom
)39(infix - ~14 recursionLimit 1 +1)
)4,9(var info . . . 14(at
 ~6(dot ~1 c 1 debug)1 pc
))4,11(var s . . . 4""),13(if
 3(elif
 23(infix
 in ~23 optExcessiveStackTrace 11(dot ~7(dot
 ~1 c 1 config
)1 globalOptions)
)~1,1(stmts
 2(asgn ~2 s 12(call
 ~10 toFullPath 2(dot ~1 c 1 config)11 info
))
)
),2(else
 2,1(stmts
 2(asgn ~2 s 12(call
 ~10 toFilename 2(dot ~1 c 1 config)11 info
))
)
)
)4,17(var
 line . . . 19(call ~12 toLinenumber 1 info)
)4,18(var
 col . . . 14(call ~8 toColumn 1 info)
),19(if
 3(elif
 5(infix > ~5 line 2 +0)~1,1(stmts
 5(call ~4(dot
 ~1 s 1 add
)1'\28')5,1(call ~4(dot ~1 s 1 add)1(prefix
 $ 1 line
))5,2(call
 ~4(dot ~1 s 1 add)1", "
)5,3(call ~4(dot ~1 s 1 add)1(prefix
 $ 1(par 5(infix
 + ~4 col 2 ColOffset
))
))5,4(call ~4(dot
 ~1 s 1 add
)1'\29')
)
)
),25(if
 3(elif
 6(infix
 != ~5(dot ~1 x 1 prc)3(nil)
)~1,1(stmts
 4(for
 6(infix
 .. ~1 +1 5(call ~3 max 1 +1 6(infix
 - ~2 +25 2(dot ~1 s 1 len)
))
)(unpackIntoFlat(let k ....))26(stmts 5(call
 ~4(dot ~1 s 1 add)1' '
))
)5,1(call
 ~4(dot ~1 s 1 add)11(dot ~5(dot
 ~4(dot ~1 x 1 prc)1 name
)1 s)
)
)
)
)10,28(call ~10 msgWriteln 2(dot ~1 c 1 config)11 s 14(curlyConstr
 1 msgNoUnitSep
))
)
)
)
)
),57(proc
 5 stackTraceImpl . . . 19(params
 . 1(param c . . 3 PCtx .)10(param
 tos . . 5 PStackFrame .
)28(param pc . . 4 int .)~17,1(param
 msg . . 5 string .
)~4,1(param lineInfo . . 10 TLineInfo .)17,1(param
 infoOrigin . . 12 InstantiationInfo .
)
)67,1(pragmas 2 noinline). 2,3(stmts
 10(call
 ~10 msgWriteln 2(dot
 ~1 c 1 config
)11"stack trace\3A \28most recent call last\29" 51(curlyConstr
 1 msgNoUnitSep
)
)13,1(call ~13 stackTraceAux 1 c 4 tos 9 pc)4,2(let
 action . . . 9(if
 3(elif
 7(infix == ~6(dot
 ~1 c 1 mode
)3 emRepl)18(stmts doRaise)
)29(else 6(stmts doNothing))
)
)4,4(let
 lineInfo . . . 11(if
 3(elif
 9(infix == ~9 lineInfo 12(dot
 ~9 TLineInfo 1 default
))31(stmts 7(at ~6(dot
 ~1 c 1 debug
)1 pc))
)46(else 6(stmts lineInfo))
)
)9,5(call
 ~9 liMessage 2(dot ~1 c 1 config)11 lineInfo 21 errGenerated 35 msg 40 action 48 infoOrigin
)
)
),67(when
 5(elif
 (prefix not 11(call
 ~7 defined 1 nimHasCallsitePragma
))~3,1(stmts (pragmas 8(kv
 ~6 pragma 2 callsite
)))
)
),70(template
 9 stackTrace . . . 19(params
 . 1(param c . . 3 PCtx .)10(param
 tos . . 5 PStackFrame .
)28(param pc . . 4 int .)1,1(param
 msg . . 5 string .
)14,1(param lineInfo . . 10 TLineInfo 31(dot
 ~9 TLineInfo 1 default
))
)74,1(pragmas 2 callsite). 2,2(stmts
 14(call
 ~14 stackTraceImpl 1 c 4 tos 9 pc 13 msg 18 lineInfo 45(call ~17 instantiationInfo 1 -2 15(vv
 ~10 fullPaths 2 true
))
),1(ret .)
)
),75(proc
 5 bailOut . . . 12(params . 1(param c . . 3 PCtx .)10(param
 tos . . 5 PStackFrame .
)). . 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 10(dot
 ~1 c 1 exceptionInstr
)48,2(infix
 & ~42(infix
 & 35,-1(infix
 & 10,-1(infix
 & ~24"unhandled exception\3A " ~18,1(dot
 ~10(dot
 ~3(at ~18(dot
 ~1 c 1 currentExceptionA
)1 +3)1 skipColon
)1 strVal
)
)~40,1" \5B"
)34(dot
 ~10(dot ~3(at
 ~18(dot ~1 c 1 currentExceptionA)1 +2
)1 skipColon)1 strVal
)
)2"\5D"
)
)
)
),80(when
 5(elif
 (prefix
 not 11(call ~7 defined 1 nimComputedGoto)
)~3,1(stmts (pragmas
 8(kv ~6 pragma 2 computedGoto)
))
)
),83(proc
 5 ensureKind . . . 15(params
 . 1(param
 n . . 3(mut 4 TFullReg).
)18(param k . . 3 TRegisterKind .)
)51(pragmas 2 inline). 2,1(stmts
 (if
 3(elif
 7(infix
 != ~6(dot ~1 n 1 kind)3 k
)~1,1(stmts
 2(asgn ~2 n 10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 k)
))
)
)
)
)
),87(template
 9 ensureKind . . . 19(params
 . 1(param k . . 3 untyped .)
)32(pragmas 2 dirty). 2,1(stmts
 10(call ~10 ensureKind 5(at
 ~4 regs 1 ra
)11 k)
)
),90(template
 9 decodeB . . . 16(params
 . 1(param k . . 3 untyped .)
)29(pragmas 2 dirty). 2,1(stmts 4(let rb . . . 10(dot
 ~5 instr 1 regB
))10,1(call
 ~10 ensureKind 1 k
))
),94(template
 9 decodeBC . . . 17(params
 . 1(param k . . 3 untyped .)
)30(pragmas 2 dirty). 2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
))10,2(call
 ~10 ensureKind 1 k
)
)
),99(template
 9 declBC . . . 15(params .)18(pragmas 2 dirty). 2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
))
)
),103(template
 9 decodeBImm . . . 19(params
 . 1(param k . . 3 untyped .)
)32(pragmas 2 dirty). 2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let
 imm . . . 17(infix - ~6(dot
 ~5 instr 1 regC
)2 byteExcess)
)10,2(call ~10 ensureKind 1 k)
)
),108(template
 9 decodeBx . . . 17(params
 . 1(param k . . 3 untyped .)
)30(pragmas 2 dirty). 2,1(stmts
 4(let
 rbx . . . 18(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)10,1(call ~10 ensureKind 1 k)
)
),112(template
 9 move . . . 13(params . 1(param a . . 6 untyped .)4(param
 b . . 3 untyped .
))29(pragmas
 2 dirty
). 2,1(stmts
 (when
 5(elif
 33(infix
 or ~18(infix or ~8(call ~7 defined 1 gcArc)10(call
 ~7 defined 1 gcOrc
))10(call
 ~7 defined 1 gcAtomicArc
)
)~3,1(stmts
 2(asgn ~2 a 7(cmd ~5 move b))
)
),2(else
 2,1(stmts 18(call
 ~12(dot ~6 system 1 shallowCopy)1 a 4 b
))
)
)
)
),119(proc
 5 derefPtrToReg . . . 18(params
 68 bool 1(param
 address . . 9 BiggestInt .
)22(param typ . . 5 PType .)34(param
 r . . 3(mut 4 TFullReg).
)51(param isAssign . . 10 bool .)
). . 2,2(stmts
 (template
 9 fun . . . 12(params
 . 1(param field . . . .)8(param
 typ . . . .
)13(param rkind . . . .)
). . 2,1(stmts
 (if
 3(elif
 isAssign ~1,1(stmts
 25(asgn
 ~3(at ~22(cast
 5(ptr 4 typ)14 address
))5(call ~3 typ 2(dot
 ~1 r 1 field
))
)
)
),2(else
 2,1(stmts
 12(call
 ~11(dot ~1 r 1 ensureKind)1 rkind
)4,1(let val . . . 28(at
 ~22(cast 5(ptr 4 typ)14 address)
)),2(when
 5(elif
 4(infix is ~4 typ 15(infix
 | ~12 SomeInteger 2 char
))~3,1(stmts 8(asgn
 ~7(dot
 ~1 r 1 field
)12(call ~10 BiggestInt 1 val)
))
),2(else
 2,1(stmts 8(asgn
 ~7(dot ~1 r 1 field)2 val
))
)
)
)
)
),9(ret 7 true)
)
),12(comment),13(case
 8(dot ~3 typ 1 kind),1(of(curlyConstr
 3 tyChar
)11(stmts
 3(call ~3 fun 1 intVal 9 char 15 rkInt)
)),2(of(curlyConstr
 3 tyInt
)10(stmts
 3(call ~3 fun 1 intVal 9 int 14 rkInt)
)),3(of(curlyConstr
 3 tyInt8
)11(stmts
 3(call ~3 fun 1 intVal 9 int8 15 rkInt)
)),4(of(curlyConstr
 3 tyInt16
)12(stmts
 3(call ~3 fun 1 intVal 9 int16 16 rkInt)
)),5(of(curlyConstr
 3 tyInt32
)12(stmts
 3(call ~3 fun 1 intVal 9 int32 16 rkInt)
)),6(of(curlyConstr
 3 tyInt64
)12(stmts
 3(call ~3 fun 1 intVal 9 int64 16 rkInt)
)),7(of(curlyConstr
 3 tyUInt
)11(stmts
 3(call ~3 fun 1 intVal 9 uint 15 rkInt)
)),8(of(curlyConstr
 3 tyUInt8
)12(stmts
 3(call ~3 fun 1 intVal 9 uint8 16 rkInt)
)),9(of(curlyConstr
 3 tyUInt16
)13(stmts
 3(call ~3 fun 1 intVal 9 uint16 17 rkInt)
)),10(of(curlyConstr
 3 tyUInt32
)13(stmts
 3(call ~3 fun 1 intVal 9 uint32 17 rkInt)
)),11(of(curlyConstr
 3 tyUInt64
)13(stmts
 3(call ~3 fun 1 intVal 9 uint64 17 rkInt)
)),12(of
(curlyConstr
 3 tyFloat
)12(stmts 3(call
 ~3 fun 1 floatVal 11 float 18 rkFloat
))
),13(of
(curlyConstr 3 tyFloat32)14(stmts 3(call
 ~3 fun 1 floatVal 11 float32 20 rkFloat
))
),14(of
(curlyConstr 3 tyFloat64)14(stmts 3(call
 ~3 fun 1 floatVal 11 float64 20 rkFloat
))
),15(else 6(stmts (ret 7 false)))
)
)
),151(proc
 5 createStrKeepNode . . . 22(params
 . 1(param
 x . . 3(mut 4 TFullReg).
)18(param keepNode . . . 9 true)
). . 2,1(stmts
 (if
 3(elif
 13(infix
 or ~7(dot
 ~5(dot ~1 x 1 node)1 isNil
)3(prefix not 4 keepNode)
)~1,1(stmts
 7(asgn ~6(dot ~1 x 1 node)9(call
 ~7 newNode 1 nkStrLit
))
)
)5,2(elif
 24(infix
 and ~12(infix == ~6(dot
 ~5(dot ~1 x 1 node)1 kind
)3 nkNilLit)4 keepNode
)~3,1(stmts
 (when
 5(elif
 7(call ~7 defined 1 useNodeIds)~3,1(stmts 4(let
 id . . . 11(dot ~5(dot
 ~1 x 1 node
)1 id)
))
)
)9,2(asgn
 ~3(at ~5(dot ~1 x 1 node))7(objConstr ~5 TNode 5(kv
 ~4 kind 2 nkStrLit
))
),3(when
 5(elif
 7(call ~7 defined 1 useNodeIds)~3,1(stmts 10(asgn
 ~4(dot ~5(dot
 ~1 x 1 node
)1 id)2 id
))
)
)
)
)5,8(elif
 45(infix
 or ~33(infix
 notin ~6(dot
 ~5(dot ~1 x 1 node)1 kind
)6(curlyConstr
 9(infix .. ~8 nkStrLit 2 nkTripleStrLit)
)
)~35,1(infix in ~11 nfAllConst 9(dot
 ~5(dot ~1 x 1 node)1 flags
))
)~3,3(stmts
 7(asgn ~6(dot ~1 x 1 node)9(call
 ~7 newNode 1 nkStrLit
))
)
)
)
)
),168(include 8 vmhooks),170(template
 9 createStr . . . 18(params . 1(param
 x . . . .
)). . 2,1(stmts
 7(asgn ~6(dot ~1 x 1 node)9(call
 ~7 newNode 1 nkStrLit
))
)
),173(template
 9 createSet . . . 18(params . 1(param x . . . .)). . 2,1(stmts 7(asgn
 ~6(dot
 ~1 x 1 node
)9(call ~7 newNode 1 nkCurly)
))
),176(proc
 5 moveConst . . . 14(params
 . 1(param
 x . . 3(mut 4 TFullReg).
)18(param y . . 3 TFullReg .)
). . 2,1(stmts
 12(call ~11(dot ~1 x 1 ensureKind)2(dot
 ~1 y 1 kind
)),1(case
 6(dot
 ~1 x 1 kind
),1(of
(curlyConstr 3 rkNone)11(stmts (discard .))
),2(of
(curlyConstr 3 rkInt)10(stmts
 9(asgn ~8(dot ~1 x 1 intVal)3(dot
 ~1 y 1 intVal
))
)
),3(of
(curlyConstr 3 rkFloat)12(stmts 11(asgn
 ~10(dot
 ~1 x 1 floatVal
)3(dot ~1 y 1 floatVal)
))
),4(of
(curlyConstr 3 rkNode)11(stmts
 7(asgn ~6(dot ~1 x 1 node)3(dot
 ~1 y 1 node
))
)
),5(of
(curlyConstr 3 rkRegisterAddr)19(stmts 10(asgn
 ~9(dot
 ~1 x 1 regAddr
)3(dot ~1 y 1 regAddr)
))
),6(of
(curlyConstr 3 rkNodeAddr)15(stmts 11(asgn
 ~10(dot
 ~1 x 1 nodeAddr
)3(dot ~1 y 1 nodeAddr)
))
)
)
)
),188(template
 9 asgnRef . . . 16(params . 1(param x . . 6 untyped .)4(param
 y . . 3 untyped .
)). . 34(stmts 9(call
 ~9 moveConst 1 x 4 y
))
),190(proc
 5 copyValue . . . 14(params
 14 PNode 1(param src . . 5 PNode .)
). . 2,1(stmts
 (if
 3(elif
 11(infix
 or ~7(infix == ~4 src 3(nil))11(infix in ~8 nfIsRef 6(dot
 ~3 src 1 flags
))
)~1,1(stmts (ret 7 src))
)
)7,2(asgn ~7 result 9(call
 ~7 newNode 4(dot ~3 src 1 kind)
))12,3(asgn
 ~6(dot
 ~6 result 1 info
)5(dot ~3 src 1 info)
)11,4(asgn
 ~5(dot ~6 result 1 typ)5(dot ~3 src 1 typ)
)13,5(asgn
 ~7(dot ~6 result 1 flags)12(infix * ~7(dot
 ~3 src 1 flags
)2 PersistentNodeFlags)
)15,6(asgn ~9(dot ~6 result 1 comment)5(dot
 ~3 src 1 comment
)),7(when
 5(elif
 7(call
 ~7 defined 1 useNodeIds
)~3,1(stmts
 (if
 3(elif
 10(infix
 == ~4(dot ~6 result 1 id)3 nodeIdToDebug
)~1,1(stmts (cmd
 echo 5"COMES FROM " 23(dot ~3 src 1 id)
))
)
)
)
)
),10(case
 8(dot ~3 src 1 kind),1(of
(curlyConstr 12(infix
 .. ~9 nkCharLit 2 nkUInt64Lit
))27(stmts 14(asgn
 ~8(dot
 ~6 result 1 intVal
)5(dot ~3 src 1 intVal)
))
),2(of
(curlyConstr
 13(infix .. ~10 nkFloatLit 2 nkFloat128Lit)
)30(stmts
 16(asgn ~10(dot ~6 result 1 floatVal)5(dot
 ~3 src 1 floatVal
))
)
),3(of
(curlyConstr 3 nkSym)10(stmts
 11(asgn ~5(dot ~6 result 1 sym)5(dot
 ~3 src 1 sym
))
)
),4(of
(curlyConstr 3 nkIdent)12(stmts 13(asgn
 ~7(dot
 ~6 result 1 ident
)5(dot ~3 src 1 ident)
))
),5(of
(curlyConstr
 11(infix .. ~8 nkStrLit 2 nkTripleStrLit)
)29(stmts
 14(asgn ~8(dot ~6 result 1 strVal)5(dot
 ~3 src 1 strVal
))
)
),6(else
 2,1(stmts
 6(call ~6 newSeq 7(dot ~6 result 1 sons)17(dot
 ~3 src 1 len
))4,1(for
 6(infix ..< ~1 +0 6(dot
 ~3 src 1 len
))(unpackIntoFlat(let i ....))~2,1(stmts 10(asgn
 ~4(at
 ~6 result 1 i
)11(call ~9 copyValue 4(at ~3 src 1 i))
))
)
)
)
)
)
),212(proc
 5 asgnComplex . . . 16(params
 . 1(param
 x . . 3(mut 4 TFullReg).
)18(param y . . 3 TFullReg .)
). . 2,1(stmts
 12(call ~11(dot ~1 x 1 ensureKind)2(dot
 ~1 y 1 kind
)),1(case
 6(dot
 ~1 x 1 kind
),1(of
(curlyConstr 3 rkNone)11(stmts (discard .))
),2(of
(curlyConstr 3 rkInt)10(stmts
 9(asgn ~8(dot ~1 x 1 intVal)3(dot
 ~1 y 1 intVal
))
)
),3(of
(curlyConstr 3 rkFloat)12(stmts 11(asgn
 ~10(dot
 ~1 x 1 floatVal
)3(dot ~1 y 1 floatVal)
))
),4(of
(curlyConstr 3 rkNode)11(stmts 7(asgn
 ~6(dot ~1 x 1 node)11(call ~9 copyValue 2(dot
 ~1 y 1 node
))
))
),5(of
(curlyConstr 3 rkRegisterAddr)19(stmts 10(asgn
 ~9(dot
 ~1 x 1 regAddr
)3(dot ~1 y 1 regAddr)
))
),6(of
(curlyConstr 3 rkNodeAddr)15(stmts 11(asgn
 ~10(dot
 ~1 x 1 nodeAddr
)3(dot ~1 y 1 nodeAddr)
))
)
)
)
),222(proc
 5 fastAsgnComplex . . . 20(params
 . 1(param
 x . . 3(mut 4 TFullReg).
)18(param y . . 3 TFullReg .)
). . 2,1(stmts
 12(call ~11(dot ~1 x 1 ensureKind)2(dot
 ~1 y 1 kind
)),1(case
 6(dot
 ~1 x 1 kind
),1(of
(curlyConstr 3 rkNone)11(stmts (discard .))
),2(of
(curlyConstr 3 rkInt)10(stmts
 9(asgn ~8(dot ~1 x 1 intVal)3(dot
 ~1 y 1 intVal
))
)
),3(of
(curlyConstr 3 rkFloat)12(stmts 11(asgn
 ~10(dot
 ~1 x 1 floatVal
)3(dot ~1 y 1 floatVal)
))
),4(of
(curlyConstr 3 rkNode)11(stmts
 7(asgn ~6(dot ~1 x 1 node)3(dot
 ~1 y 1 node
))
)
),5(of
(curlyConstr 3 rkRegisterAddr)19(stmts 10(asgn
 ~9(dot
 ~1 x 1 regAddr
)3(dot ~1 y 1 regAddr)
))
),6(of
(curlyConstr 3 rkNodeAddr)15(stmts 11(asgn
 ~10(dot
 ~1 x 1 nodeAddr
)3(dot ~1 y 1 nodeAddr)
))
)
)
)
),232(proc
 5 writeField . . . 15(params
 . 1(param
 n . . 3(mut 4 PNode).
)15(param x . . 3 TFullReg .)
). . 2,1(stmts
 (case
 6(dot ~1 x 1 kind),1(of(curlyConstr 3 rkNone)11(stmts (discard
 .
))),2(of
(curlyConstr
 3 rkInt
)2,1(stmts
 (if
 3(elif
 7(infix
 == ~6(dot ~1 n 1 kind)3 nkNilLit
)~1,1(stmts
 4(asgn ~3(at ~1 n)7(objConstr
 ~5 TNode 5(kv ~4 kind 2 nkIntLit)
))
)
)
)9,2(asgn
 ~8(dot ~1 n 1 intVal)3(dot ~1 x 1 intVal)
)
)
),6(of
(curlyConstr 3 rkFloat)12(stmts 11(asgn
 ~10(dot
 ~1 n 1 floatVal
)3(dot ~1 x 1 floatVal)
))
),7(of
(curlyConstr 3 rkNode)11(stmts 2(asgn
 ~2 n 11(call ~9 copyValue 2(dot
 ~1 x 1 node
))
))
),8(of
(curlyConstr 3 rkRegisterAddr)19(stmts 10(call
 ~10 writeField 1 n 13(at ~8(dot
 ~1 x 1 regAddr
))
))
),9(of
(curlyConstr 3 rkNodeAddr)15(stmts
 2(asgn ~2 n 12(at ~9(dot
 ~1 x 1 nodeAddr
)))
)
)
)
)
),244(proc
 5 putIntoReg . . . 15(params
 . 1(param
 dest . . 6(mut 4 TFullReg).
)21(param n . . 3 PNode .)
). . 2,1(stmts
 (case
 6(dot ~1 n 1 kind),1(of
(curlyConstr 11(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))2,1(stmts
 5(asgn
 ~5 dest 10(objConstr
 ~8 TFullReg 5(kv
 ~4 kind 2 rkNode
)19(kv ~4 node 12(call
 ~10 newStrNode 1 nkStrLit 12(dot ~1 n 1 strVal)
))
)
)
)
),3(of
(curlyConstr 3 nkIntLit)2,1(stmts
 (if
 3(elif
 10(infix == ~6(dot
 ~4 dest 1 kind
)3 rkNode)21(stmts
 10(asgn ~6(dot
 ~4 dest 1 node
)2 n)
)
)5,1(elif
 13(infix
 and ~7(infix
 != ~5(dot ~1 n 1 typ)3(nil)
)15(infix
 in ~6(dot ~4(dot ~1 n 1 typ)1 kind)3 PtrLikeKinds
)
)~3,1(stmts
 5(asgn
 ~5 dest 10(objConstr ~8 TFullReg 5(kv ~4 kind 2 rkNode)19(kv
 ~4 node 2 n
))
)
)
),3(else
 2,1(stmts
 5(asgn
 ~5 dest 10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkInt)20(kv ~6 intVal 3(dot
 ~1 n 1 intVal
))
)
)
)
)
)
)
),9(of
(curlyConstr
 28(infix
 - ~25(curlyConstr
 10(infix .. ~9 nkCharLit 2 nkUInt64Lit)
)2(curlyConstr 1 nkIntLit)
)
)2,1(stmts
 5(asgn
 ~5 dest 10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkInt)20(kv ~6 intVal 3(dot
 ~1 n 1 intVal
))
)
)
)
),11(of
(curlyConstr
 13(infix .. ~10 nkFloatLit 2 nkFloat128Lit)
)2,1(stmts
 5(asgn
 ~5 dest 10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkFloat)24(kv ~8 floatVal 3(dot
 ~1 n 1 floatVal
))
)
)
)
),13(else
 2,1(stmts
 5(asgn
 ~5 dest 10(objConstr ~8 TFullReg 5(kv ~4 kind 2 rkNode)19(kv
 ~4 node 2 n
))
)
)
)
)
)
),261(proc
 5 regToNode . . . 14(params
 15 PNode 1(param x . . 3 TFullReg .)
). . 2,1(stmts
 (case
 6(dot ~1 x 1 kind),1(of
(curlyConstr 3 rkNone)11(stmts
 7(asgn ~7 result 9(call
 ~7 newNode 1 nkEmpty
))
)
),2(of
(curlyConstr 3 rkInt)10(stmts
 7(asgn ~7 result 9(call
 ~7 newNode 1 nkIntLit
))42(asgn
 ~8(dot
 ~6 result 1 intVal
)3(dot ~1 x 1 intVal)
)
)
),3(of
(curlyConstr 3 rkFloat)12(stmts
 7(asgn ~7 result 9(call
 ~7 newNode 1 nkFloatLit
))46(asgn
 ~10(dot
 ~6 result 1 floatVal
)3(dot ~1 x 1 floatVal)
)
)
),4(of
(curlyConstr 3 rkNode)11(stmts 7(asgn
 ~7 result 3(dot ~1 x 1 node)
))
),5(of
(curlyConstr 3 rkRegisterAddr)19(stmts 7(asgn
 ~7 result 11(call ~9 regToNode 10(at ~8(dot
 ~1 x 1 regAddr
)))
))
),6(of
(curlyConstr 3 rkNodeAddr)15(stmts
 7(asgn ~7 result 12(at ~9(dot
 ~1 x 1 nodeAddr
)))
)
)
)
)
),270(template
 9 getstr . . . 15(params
 14 untyped 1(param a . . 3 untyped .)
). . 2,1(stmts
 (expr
 .(stmts)1(if
 3(elif
 7(infix
 == ~6(dot ~1 a 1 kind)3 rkNode
)24(dot ~5(dot ~1 a 1 node)1 strVal)
)35(else 6(prefix
 $ 4(call ~3 chr 4(call
 ~3 int 2(dot ~1 a 1 intVal)
))
))
)
)
)
),273(proc
 5 pushSafePoint . . . 18(params . 1(param f . . 3 PStackFrame .)17(param
 pc . . 4 int .
)). . 2,1(stmts 16(call
 ~4(dot ~11(dot
 ~1 f 1 safePoints
)1 add)1 pc
))
),276(proc
 5 popSafePoint . . . 17(params
 . 1(param f . . 3 PStackFrame .)
). . 2,1(stmts (discard
 24(call ~4(dot
 ~11(dot ~1 f 1 safePoints)1 pop
))
))
)16,280(type
 ~14 ExceptionGoto . . . 2(enum
~14,1(enumFieldDecl
~14,1 ExceptionGotoHandler . . . .
)~14,2(enumFieldDecl
~14,2 ExceptionGotoFinally . . . .
)~14,3(enumFieldDecl
~14,3 ExceptionGotoUnhandled . . . .
)
)
),285(proc
 5 findExceptionHandler . . . 25(params
 ~21,1(tuple
 6(param
 why . . 5 ExceptionGoto .
)26(param where . . 7 int .)
)1(param c . . 3 PCtx .)10(param
 f . . 3 PStackFrame .
)26(param exc . . 5 PNode .)
). . 2,2(stmts
 4(let
 raisedType . . . 30(call ~10(dot
 ~4(dot ~3 exc 1 typ)1 skipTypes
)1 abstractPtrs)
),2(while
 23(infix > ~5(dot
 ~11(dot ~1 f 1 safePoints)1 len
)2 +0)2,1(stmts
 4(var pc . . . 21(call
 ~4(dot ~11(dot
 ~1 f 1 safePoints
)1 pop)
))4,2(var
 matched . . . 10 false
)4,3(var pcEndExcept . . . 14 pc),20(while
 24(infix
 == ~8(dot
 ~4(at ~5(dot
 ~1 c 1 code
)1 pc)1 opcode
)3 opcExcept
)2,2(stmts
 12(asgn
 ~12 pcEndExcept 24(infix
 - ~19(infix
 + ~3 pc 12(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 regBx)
)2 wordExcess
)
),1(cmd inc 4 pc),4(while
 24(infix
 == ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3 opcExcept
)2,1(stmts
 4(let
 excIndex . . . 28(infix
 - ~7(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 regBx)2 wordExcess
)
)4,1(let
 exceptType . . . ~2,1(if
 3(elif
 9(infix > ~9 excIndex 2 +0)14(stmts
 27(call
 ~10(dot
 ~10(at ~6(dot
 ~1 c 1 types
)1 excIndex)1 skipTypes
)1 abstractPtrs
)
)
),1(else 6(stmts (nil)))
)
),8(if
 3(elif
 17(infix
 or ~7(dot ~10 exceptType 1 isNil)43(infix <= ~25(call
 ~15 inheritanceDiff 1 raisedType 13 exceptType
)3 +0)
)~1,1(stmts
 8(asgn ~8 matched 2 true),1(brk .)
)
)
),12(cmd inc 4 pc)
)
),21(while
 24(infix
 == ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3 opcExcept
)2,1(stmts (cmd inc 4 pc))
),24(if
 3(elif matched ~1,1(stmts (brk .)))
)3,30(asgn ~3 pc 2 pcEndExcept)
)
)4,55(let pcBody . . . 9 pc),57(if
 3(elif matched ~1,1(stmts
 (ret 7(tupleConstr
 1 ExceptionGotoHandler 23 pcBody
))
))5,2(elif
 18(infix
 == ~8(dot
 ~4(at ~5(dot
 ~1 c 1 code
)1 pc)1 opcode
)3 opcFinally
)~3,3(stmts
 (ret 7(tupleConstr
 1 ExceptionGotoFinally 26(infix + ~3 pc 2 +1)
))
)
)
)
)
),67(ret
 7(tupleConstr 1 ExceptionGotoUnhandled 25 +0)
)
)
),356(proc
 5 cleanUpOnReturn . . . 20(params 27 int 1(param c . . 3 PCtx .)10(param
 f . . 3 PStackFrame .
)). . 2,4(stmts
 7(asgn
 ~7 result 2 -1
)4,4(for
 6(infix .. ~1 +1 14(dot
 ~11(dot ~1 f 1 safePoints)1 len
))(unpackIntoFlat
(let i ....)
)~2,1(stmts
 4(var
 pc . . . 17(at ~11(dot ~1 f 1 safePoints)1(prefix
 ^ 1 i
))
),2(while
 24(infix
 == ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3 opcExcept
)2,1(stmts
 3(infix
 += ~3 pc 20(infix
 - ~7(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 regBx)2 wordExcess
)
)
)
),4(if
 3(elif
 18(infix
 == ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3 opcFinally
)~1,1(stmts
 (discard 20(dot
 ~11(dot ~1 f 1 safePoints)1 pop
)),1(ret 10(infix
 + ~3 pc 2 +1
))
)
)
)
)
)
)
),373(proc
 5 opConv . . . 11(params
 70 bool 1(param c . . 3 PCtx .)10(param dest . . 6(mut
 4 TFullReg
).)30(param
 src . . 5 TFullReg .
)45(param desttyp . . 17 PType .)54(param
 srctyp . . 8 PType .
)
). . 2,1(stmts
 7(asgn ~7 result 2 false),1(if
 3(elif
 13(infix == ~6(dot
 ~7 desttyp 1 kind
)3 tyString)~1,1(stmts
 15(call ~11(dot
 ~4 dest 1 ensureKind
)1 rkNode)10,1(asgn
 ~6(dot
 ~4 dest 1 node
)9(call ~7 newNode 1 nkStrLit)
)4,2(let styp . . . 23(call
 ~10(dot ~6 srctyp 1 skipTypes)1 abstractRange
)),3(case
 9(dot
 ~4 styp 1 kind
),1(of
(curlyConstr 3 tyEnum)2,1(stmts
 4(let
 n . . . 8(dot ~4 styp 1 n)
)4,1(let x . . . 14(dot
 ~7(dot ~3 src 1 intVal)1 int
)),2(if
 3(elif
 11(infix
 and ~9(infix <% ~2 x 4(dot
 ~1 n 1 len
))4(expr
 .(stmts
 5(let f . . . 8(dot
 ~3(at ~1 n 1 x)1 sym
))
)30(infix
 == ~10(dot ~1 f 1 position)3 x
)
)
)~1,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2(if
 3(elif
 5(dot ~4(dot ~1 f 1 ast)1 isNil)13(stmts 6(dot ~5(dot
 ~1 f 1 name
)1 s))
)25(else 6(stmts
 5(dot ~4(dot ~1 f 1 ast)1 strVal)
))
)
)
)
),2(else
 2,1(stmts
 4(for
 6(infix
 ..< ~1 +0 4(dot ~1 n 1 len)
)(unpackIntoFlat(let i ....))~2,1(stmts
 (if
 3(elif
 10(infix
 != ~6(dot ~3(at
 ~1 n 1 i
)1 kind)3 nkSym
)20(stmts 13(call
 ~13 internalError 2(dot ~1 c 1 config)11"opConv for enum"
))
)
)4,1(let
 f . . . 8(dot ~3(at ~1 n 1 i)1 sym)
),2(if
 3(elif
 11(infix
 == ~10(dot ~1 f 1 position)3 x
)~1,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2(if
 3(elif
 5(dot ~4(dot ~1 f 1 ast)1 isNil)13(stmts 6(dot ~5(dot
 ~1 f 1 name
)1 s))
)25(else 6(stmts
 5(dot ~4(dot ~1 f 1 ast)1 strVal)
))
)
),1(ret .)
)
)
)
)
)17,6(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)24(infix
 & ~6(infix
 & ~3(dot ~5(dot
 ~4(dot ~4 styp 1 sym)1 name
)1 s)2" "
)2(prefix $ 1 x)
)
)
)
)
)
)
),14(of
(curlyConstr
 8(infix .. ~5 tyInt 2 tyInt64)
)2,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2(prefix $ 4(dot ~3 src 1 intVal))
)
)
),16(of
(curlyConstr
 9(infix .. ~6 tyUInt 2 tyUInt64)
)2,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2(prefix $ 7(call
 ~6 uint64 4(dot ~3 src 1 intVal)
))
)
)
),18(of
(curlyConstr 3 tyBool)2,1(stmts
 17(asgn
 ~8(dot ~5(dot
 ~4 dest 1 node
)1 strVal)2(if
 3(elif
 11(infix == ~8(dot
 ~3 src 1 intVal
)3 +0)17(stmts "false")
)28(else 6(stmts "true"))
)
)
)
),20(of
(curlyConstr
 10(infix .. ~7 tyFloat 2 tyFloat128)
)2,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2(prefix $ 4(dot ~3 src 1 floatVal))
)
)
),22(of
(curlyConstr 3 tyString)2,1(stmts
 17(asgn
 ~8(dot ~5(dot
 ~4 dest 1 node
)1 strVal)10(dot ~5(dot
 ~3 src 1 node
)1 strVal)
)
)
),24(of
(curlyConstr 3 tyCstring)2,1(stmts
 (if
 3(elif
 14(infix
 == ~6(dot ~5(dot
 ~3 src 1 node
)1 kind)3 nkBracket
)~1,2(stmts
 4(var strVal . . . 9"")4,1(for
 15(dot ~5(dot
 ~3 src 1 node
)1 sons)(unpackIntoFlat
(let son ....)
)~2,1(stmts
 4(let c . . . 8(call
 ~4 char 4(dot ~3 son 1 intVal)
)),1(if
 3(elif 2(infix
 == ~2 c 3'\00'
)11(stmts (brk .)))
)10,2(call
 ~4(dot ~6 strVal 1 add)1 c
)
)
)17,5(asgn ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)2 strVal)
)
),8(else
 2,1(stmts
 17(asgn
 ~8(dot
 ~5(dot ~4 dest 1 node)1 strVal
)10(dot
 ~5(dot ~3 src 1 node)1 strVal
)
)
)
)
)
)
),35(of
(curlyConstr 3 tyChar)2,1(stmts
 17(asgn
 ~8(dot ~5(dot
 ~4 dest 1 node
)1 strVal)2(prefix
 $ 4(call ~3 chr 4(dot
 ~3 src 1 intVal
))
)
)
)
),37(else
 2,1(stmts
 13(call
 ~13 internalError 2(dot ~1 c 1 config)39(infix & ~28"cannot convert to string " 9(dot
 ~7 desttyp 1 typeToString
))
)
)
)
)
)
),43(else
 2,1(stmts
 4(let desttyp . . . 19(call
 ~9 skipTypes 1 desttyp 10 abstractVarRange
)),1(case
 12(dot
 ~7 desttyp 1 kind
),1(of
(curlyConstr
 8(infix .. ~5 tyInt 2 tyInt64)
)2,1(stmts
 15(call
 ~11(dot ~4 dest 1 ensureKind)1 rkInt
),1(case
 37(dot ~23(call
 ~9 skipTypes 1 srctyp 9 abstractRange
)1 kind),1(of
(curlyConstr 10(infix
 .. ~7 tyFloat 2 tyFloat64
))2,1(stmts
 12(asgn ~8(dot
 ~4 dest 1 intVal
)5(call
 ~3 int 4(dot ~3 src 1 floatVal)
))
)
),3(else 2,1(stmts
 12(asgn ~8(dot ~4 dest 1 intVal)5(dot
 ~3 src 1 intVal
))
))
),6(if
 3(elif
 52(infix
 or ~30(infix
 < ~14(call
 ~8 toInt128 5(dot ~4 dest 1 intVal)
)10(call
 ~8 firstOrd 2(dot ~1 c 1 config)11 desttyp
)
)25(infix
 > ~14(call
 ~8 toInt128 5(dot ~4 dest 1 intVal)
)9(call
 ~7 lastOrd 2(dot ~1 c 1 config)11 desttyp
)
)
)~1,1(stmts (ret 7 true))
)
)
)
),10(of
(curlyConstr
 9(infix .. ~6 tyUInt 2 tyUInt64)
)2,1(stmts
 15(call
 ~11(dot ~4 dest 1 ensureKind)1 rkInt
)4,1(let styp . . . 23(call
 ~10(dot ~6 srctyp 1 skipTypes)1 abstractRange
)),2(case
 9(dot
 ~4 styp 1 kind
),1(of
(curlyConstr
 10(infix .. ~7 tyFloat 2 tyFloat64)
)2,1(stmts
 12(asgn
 ~8(dot ~4 dest 1 intVal)5(call ~3 int 4(dot
 ~3 src 1 floatVal
))
)
)
),3(else
 2,1(stmts
 4(let destSize . . . 18(call
 ~7 getSize 2(dot ~1 c 1 config)11 desttyp
))4,1(let
 destDist . . . 44(infix
 * ~33(par 21(infix
 - ~14(call ~6 sizeof 5(dot
 ~4 dest 1 intVal
))2 destSize
))2 +8
)
)4,2(var value . . . 8(cast
 5 BiggestUInt 21(dot ~3 src 1 intVal)
)),3(when
 5(elif
 false ~3,4(stmts
 4(let
 srcSize . . . 17(call ~7 getSize 2(dot
 ~1 c 1 config
)11 styp)
)4,1(let
 srcDist . . . 41(infix
 * ~31(par 20(infix
 - ~13(call ~6 sizeof 4(dot
 ~3 src 1 intVal
))2 srcSize
))2 +8
)
)6,2(asgn
 ~6 value 22(infix shr ~20(par
 7(infix shl ~6 value 4 srcDist)
)4 srcDist)
)
)
)
)6,10(asgn
 ~6 value 23(infix shr ~21(par
 7(infix shl ~6 value 4 destDist)
)4 destDist)
)12,11(asgn ~8(dot ~4 dest 1 intVal)2(cast
 5 BiggestInt 17 value
))
)
)
)
)
),29(of
(curlyConstr 3 tyBool)2,1(stmts
 15(call ~11(dot
 ~4 dest 1 ensureKind
)1 rkInt)12,1(asgn
 ~8(dot
 ~4 dest 1 intVal
)~10,1(case
 37(dot ~23(call
 ~9 skipTypes 1 srctyp 9 abstractRange
)1 kind)2,1(of
(curlyConstr 10(infix
 .. ~7 tyFloat 2 tyFloat64
))23(stmts 3(call
 ~3 int 14(infix != ~10(dot
 ~3 src 1 floatVal
)3 +0.0)
))
)2,2(else 6(stmts
 3(call ~3 int 12(infix
 != ~8(dot ~3 src 1 intVal)3 +0
))
))
)
)
)
),35(of
(curlyConstr
 10(infix .. ~7 tyFloat 2 tyFloat64)
)2,1(stmts
 15(call
 ~11(dot ~4 dest 1 ensureKind)1 rkFloat
)4,1(let
 srcKind . . . 42(dot ~23(call
 ~9 skipTypes 1 srctyp 9 abstractRange
)1 kind)
),2(case
 5 srcKind ,1(of
(curlyConstr
 8(infix .. ~5 tyInt 2 tyInt64)25(infix
 .. ~6 tyUInt 2 tyUInt64
)37 tyEnum 45 tyBool 53 tyChar
)2,1(stmts
 14(asgn
 ~10(dot ~4 dest 1 floatVal)16(call ~14 toBiggestFloat 4(dot
 ~3 src 1 intVal
))
)
)
),3(elif
 14(infix
 == ~6(dot ~3 src 1 kind)3 rkInt
)2,1(stmts
 14(asgn
 ~10(dot ~4 dest 1 floatVal)16(call ~14 toBiggestFloat 4(dot
 ~3 src 1 intVal
))
)
)
),5(else 2,1(stmts
 14(asgn ~10(dot ~4 dest 1 floatVal)5(dot
 ~3 src 1 floatVal
))
))
)
)
),45(of
(curlyConstr 3 tyObject)2,1(stmts
 (if
 3(elif
 40(infix
 != ~6(dot
 ~18(call ~10(dot
 ~6 srctyp 1 skipTypes
)1 abstractVarRange)1 kind
)3 tyObject
)~1,1(stmts
 13(call
 ~13 internalError 2(dot ~1 c 1 config)11"invalid object-to-object conversion"
)
)
)
)9,3(call ~9 moveConst 1 dest 7 src)
)
),50(else 2,1(stmts
 11(call ~11 asgnComplex 1 dest 7 src)
))
)
)
)
)
)
),473(proc
 5 compile . . . 12(params 20 int 1(param c . . 3 PCtx .)10(param
 s . . 3 PSym .
)). . 2,1(stmts
 7(asgn
 ~7 result 15(call ~8(dot
 ~5 vmgen 1 genProc
)1 c 4 s)
),1(when 5(elif
 debugEchoCode 15(stmts 1(cmd
 (dot ~1 c 1 echoCode)10 result
))
))
)
),478(template
 9 handleJmpBack . . . 22(params .)25(pragmas 2 dirty). 2,1(stmts
 (if
 3(elif
 17(infix <= ~16(dot
 ~1 c 1 loopIterations
)3 +0)~1,1(stmts
 (if
 3(elif
 19(infix in ~19 allowInfiniteLoops 4(dot
 ~1 c 1 features
))~1,1(stmts
 17(asgn
 ~16(dot
 ~1 c 1 loopIterations
)10(dot
 ~7(dot ~1 c 1 config)1 maxLoopIterationsVM
)
)
)
),2(else
 2,1(stmts
 10(call
 ~10 msgWriteln 2(dot ~1 c 1 config)11"stack trace\3A \28most recent call last\29" 51(curlyConstr
 1 msgNoUnitSep
)
)13,1(call ~13 stackTraceAux 1 c 4 tos 9 pc)11,2(call
 ~11 globalError 2(dot
 ~1 c 1 config
)18(at ~6(dot ~1 c 1 debug)1 pc)45(infix
 % ~21 errTooManyIterations 2(prefix
 $ 9(dot ~7(dot
 ~1 c 1 config
)1 maxLoopIterationsVM)
)
)
)
)
)
)
)
)
)3,7(call
 ~3 dec 2(dot ~1 c 1 loopIterations)
)
)
),488(proc
 5 recSetFlagIsRef . . . 20(params
 . 1(param arg . . 5 PNode .)
). . 2,1(stmts
 (if
 3(elif
 9(infix
 notin ~6(dot ~3 arg 1 kind)6(curlyConstr 9(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))
)~1,1(stmts
 14(call ~5(dot
 ~6(dot ~3 arg 1 flags)1 incl
)1 nfIsRef)
)
)
)4,2(for
 6(infix
 ..< ~1 +0 6(dot ~3 arg 1 safeLen)
)(unpackIntoFlat(let i ....))~2,1(stmts 6(dot
 ~3(at ~3 arg 1 i)1 recSetFlagIsRef
))
)
)
),494(proc
 5 setLenSeq . . . 14(params
 . 1(param c . . 3 PCtx .)10(param
 node . . 6 PNode .
)23(param newLen . . 8 int .)36(param
 info . . 6 TLineInfo .
)
). . 2,1(stmts
 4(let
 typ . . . 24(call
 ~10(dot
 ~4(dot ~4 node 1 typ)1 skipTypes
)23(infix
 - ~10(infix
 + ~12 abstractInst 1(curlyConstr 1 tyRange)
)1(curlyConstr 1 tyTypeDesc)
)
)
)4,1(let
 oldLen . . . 13(dot ~4 node 1 len)
)6,2(call
 ~6 setLen 5(dot ~4 node 1 sons)12 newLen
),3(if
 3(elif
 7(infix < ~7 oldLen 2 newLen)~1,1(stmts
 4(for
 11(infix
 ..< ~6 oldLen 3 newLen
)(unpackIntoFlat(let i ....))~2,1(stmts
 8(asgn
 ~4(at
 ~4 node 1 i
)14(call ~12 getNullValue 4(dot ~3 typ 1 elementType)18 info 25(dot
 ~1 c 1 config
))
)
)
)
)
)
)
)
)2,503(const
 errNilAccess . . . 15"attempt to access a nil address"
)2,504(const
 errOverOrUnderflow . . . 21"over- or underflow"
)2,505(const
 errConstantDivisionByZero . . . 28"division by zero"
)2,506(const
 errIllegalConvFromXtoY . . . 25"illegal conversion from \27$1\27 to \27$2\27"
)2,507(const
 errTooManyIterations . . . 71(infix
 & ~48"interpretation requires too many iterations; " ~69,1"if you are sure this is not a bug in your code, compile with `--maxLoopIterationsVM\3Anumber` \28current value\3A $1\29"
)
)2,509(const
 errFieldXNotFound . . . 20"node lacks field\3A "
),512(template
 9 maybeHandlePtr . . . 23(params
 48 bool 1(param
 node2 . . 7 PNode .
)15(param reg . . 5 TFullReg .)30(param
 isAssign2 . . 11 bool .
)
). . 2,1(stmts
 4(let node . . . 7 node2),1(if
 3(elif
 10(infix == ~6(dot
 ~4 node 1 kind
)3 nkNilLit)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
)
)4,3(let
 typ . . . 10(dot ~4 node 1 typ)
),4(if
 3(elif
 22(infix
 or ~14(infix
 in ~8 nfIsPtr 7(dot ~4 node 1 flags)
)3(par
 12(infix
 and ~7(infix != ~4 typ 3(nil))13(infix == ~6(dot
 ~3 typ 1 kind
)3 tyPtr)
)
)
)~1,1(stmts
 (cmd
 assert 17(infix
 == ~6(dot ~4 node 1 kind)3 nkIntLit
)30(prefix
 $ 1(par 5(dot ~4 node 1 kind))
)
),1(cmd
 assert 11(infix != ~4 typ 3(nil))
)4,2(let
 typ2 . . . 7(if
 3(elif
 9(infix
 == ~6(dot ~3 typ 1 kind)3 tyPtr
)19(stmts
 3(dot ~3 typ 1 elementType)
)
)38(else 6(stmts typ))
)
),3(if
 3(elif
 (prefix
 not 17(call
 ~13 derefPtrToReg 5(dot ~4 node 1 intVal)14 typ2 20 reg 34(vv
 ~9 isAssign 2 isAssign2
)
)
)~1,2(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 44(infix
 & ~31"deref unsupported ptr type\3A " 2(prefix $ 1(tupleConstr
 13(call
 ~12 typeToString 1 typ
)23(dot ~3 typ 1 kind)
))
)
)
)
)
),6 true
)
),8(else 2,1(stmts false))
)
)
),528(template
 9 takeAddress . . . 20(params . 1(param reg . . . .)6(param
 source . . . .
)). . 2,1(stmts
 13(asgn
 ~10(dot
 ~3 reg 1 nodeAddr
)7(cmd ~5 addr source)
),1(cmd GC_ref 7 source)
)
),532(proc
 5 takeCharAddress . . . 20(params
 51 TFullReg 1(param c . . 3 PCtx .)10(param
 src . . 5 PNode .
)22(param index . . 7 BiggestInt .)41(param
 pc . . 4 int .
)
). . 2,1(stmts
 4(let
 typ . . . 13(call
 ~7 newType 1 tyPtr 9(dot ~1 c 1 idgen)25(dot ~7(dot
 ~1 c 1 module
)1 owner)
)
)3,1(cmd
 (dot ~3 typ 1 add)15(call
 ~10 getSysType 2(dot
 ~1 c 1 graph
)17(at ~6(dot ~1 c 1 debug)1 pc)23 tyChar
)
)4,2(var
 node . . . 16(call ~9 newNodeIT 1 nkIntLit 18(at
 ~6(dot ~1 c 1 debug)1 pc
)24 typ)
)12,3(asgn
 ~8(dot ~4 node 1 intVal)2(cast 5 int 27(dot
 ~7(at ~7(dot
 ~3 src 1 strVal
)1 index)1 addr
))
)10,4(cmd (dot
 ~6(dot ~4 node 1 flags)1 incl
)6 nfIsPtr)8,5(objConstr
 ~8 TFullReg 5(kv
 ~4 kind 2 rkNode
)19(kv ~4 node 2 node)
)
)
),541(proc
 5 rawExecute . . . 15(params
 41 TFullReg 1(param c . . 3 PCtx .)10(param
 start . . 7 int .
)22(param tos . . 5 PStackFrame .)
). . 2,1(stmts
 7(asgn ~7 result 10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkNone)
))4,1(var
 pc . . . 5 start
)4,2(var tos . . . 6 tos)4,4(var
 savedPC . . . 10 -1
)4,5(var savedFrame . . 12 PStackFrame 26(nil)),6(when
 5(elif
 33(infix
 or ~18(infix
 or ~8(call
 ~7 defined 1 gcArc
)10(call ~7 defined 1 gcOrc)
)10(call ~7 defined 1 gcAtomicArc)
)~3,1(stmts
 (template
 9 updateRegsAlias . . . 25(params .). . 27(stmts (discard .))
),1(template
 9 regs . . . 13(params 2 untyped). . 25(stmts 3(dot
 ~3 tos 1 slots
))
)
)
),3(else
 2,1(stmts
 (template
 9 updateRegsAlias . . . 25(params .). . 2,1(stmts
 4(call ~4 move 1 regs 10(dot
 ~3 tos 1 slots
))
)
)4,2(var
 regs . . 9(at ~3 seq 1 TFullReg).
),3 updateRegsAlias
)
)
),15(while
 6 true 2,2(stmts
 4(let instr . . . 14(at
 ~5(dot ~1 c 1 code)1 pc
))4,1(let ra . . . 10(dot
 ~5 instr 1 regA
)),3(when
 5(elif
 traceCode ~3,1(stmts
 (template
 9 regDescr . . . 17(params
 11 string 1(param
 name . . . .
)7(param r . . . .)
). . 2,1(stmts
 4(let
 kind . . . 7(if
 3(elif
 2(infix
 < ~2 r 6(dot ~4 regs 1 len)
)14(stmts (prefix
 $ 8(dot ~3(at ~4 regs 1 r)1 kind)
))
)31(else 6(stmts ""))
)
)4,1(let
 ret . . . 29(infix
 & ~6(infix
 & ~5(infix & ~7(infix & ~5 name 2"\3A ")2(prefix
 $ 1 r
))2" "
)2(prefix $ 1 kind)
)
)9,2(call ~9 alignLeft 1 ret 6 +15)
)
),4(cmd
 echo 34(infix
 % ~29"PC\3A$pc $opcode $ra $rb $rc" 2(bracketConstr
 ~34,1"pc" ~28,1(prefix
 $ 1 pc
)~23,1"opcode" ~4,1(call
 ~9 alignLeft 1(prefix
 $ 11(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)
)21 +15
)~34,2"ra" ~20,2(call ~8 regDescr 1"ra" 7 ra)~8,2"rb" 6,2(call ~8 regDescr 1"rb" 12(dot
 ~5 instr 1 regB
))~34,3"rc" ~20,3(call ~8 regDescr 1"rc" 12(dot
 ~5 instr 1 regC
))
)
)
)
)
)
),12(if
 3(elif
 8(dot
 ~7(dot ~1 c 1 config)1 isVmTrace
)~1,2(stmts
 4(let info . . . 14(at
 ~6(dot ~1 c 1 debug)1 pc
)),2(cmd
 echo 18(infix
 % ~13"$\23 \5B$\23\5D $\23" 2(bracketConstr
 9(infix $ ~7(dot
 ~1 c 1 config
)1 info)16(prefix $ 6(dot
 ~5 instr 1 opcode
))50(call ~11(dot
 ~7(dot ~1 c 1 config)1 sourceLine
)1 info)
)
)
)
)
)
)16,17(call ~6(dot
 ~9(dot ~1 c 1 profiler)1 enter
)1 c 4 tos),18(case
 10(dot
 ~5 instr 1 opcode
),1(of
(curlyConstr 3 opcEof)11(stmts (ret
 11(at ~4 regs 1 ra)
))
),2(of
(curlyConstr 3 opcRet)2,1(stmts
 4(let
 newPc . . . 25(call ~16(dot
 ~1 c 1 cleanUpOnReturn
)1 tos)
),2(if
 3(elif
 6(infix < ~6 newPc 2 +0)~1,1(stmts
 3(asgn ~3 pc 5(dot
 ~3 tos 1 comesFrom
))4,1(let retVal . . . 13(at
 ~4 regs 1 +0
))4,2(asgn ~4 tos 5(dot
 ~3 tos 1 next
)),3(if
 3(elif 3(dot ~3 tos 1 isNil)~1,1(stmts (ret
 7 retVal
)))
),6 updateRegsAlias ,7(cmd
 assert 25(infix
 in ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3(curlyConstr
 1 opcIndCall 13 opcIndCallAsgn
)
)
),8(if
 3(elif
 18(infix
 == ~8(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 opcode)3 opcIndCallAsgn
)~1,1(stmts
 22(asgn
 ~18(at
 ~4 regs 11(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 regA)
)2 retVal
)
)
)
)
)
),11(else
 2,1(stmts
 8(asgn ~8 savedPC 2 pc)11,1(asgn
 ~11 savedFrame 2 tos
)3,3(asgn
 ~3 pc 8(infix - ~6 newPc 2 +1)
)
)
)
)
)
),21(of(curlyConstr 3 opcYldYoid)15(stmts
 (cmd assert 7 false)
)),22(of
(curlyConstr
 3 opcYldVal
)14(stmts (cmd assert 7 false))
),23(of
(curlyConstr 3 opcAsgnInt)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)10(dot ~4(at ~4 regs 1 rb)1 intVal)
)
)
),26(of
(curlyConstr 3 opcAsgnFloat)2,1(stmts
 7(call
 ~7 decodeB 1 rkFloat
)18,1(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)
)
)
),29(of
(curlyConstr 3 opcCastFloatToInt32)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))10,1(call
 ~10 ensureKind 1 rkInt
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(cast
 5 int32 19(call ~7 float32 9(dot
 ~4(at ~4 regs 1 rb)1 floatVal
))
)
)
)
),33(of
(curlyConstr 3 opcCastFloatToInt64)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))10,1(call
 ~10 ensureKind 1 rkInt
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(cast 5 int64 20(dot
 ~4(at ~4 regs 1 rb)1 floatVal
))
)
)
),37(of
(curlyConstr 3 opcCastIntToFloat32)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))10,1(call
 ~10 ensureKind 1 rkFloat
)18,2(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)2(cast 5 float32 22(dot
 ~4(at ~4 regs 1 rb)1 intVal
))
)
)
),41(of
(curlyConstr 3 opcCastIntToFloat64)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))10,1(call
 ~10 ensureKind 1 rkFloat
)18,2(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)2(cast 5 float64 22(dot
 ~4(at ~4 regs 1 rb)1 intVal
))
)
)
),46(of
(curlyConstr 3 opcCastPtrToInt)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
),1(case
 5 imm ,1(of
(curlyConstr 3 +1)2,1(stmts
 (case
 13(dot
 ~4(at ~4 regs 1 rb)1 kind
),1(of
(curlyConstr 3 rkNode)2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(cast
 5 int 23(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 intVal)
)
)
)
),3(of
(curlyConstr 3 rkNodeAddr)2,1(stmts
 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)2(cast
 5 int 18(dot ~4(at
 ~4 regs 1 rb
)1 nodeAddr)
)
)
)
),5(of
(curlyConstr 3 rkInt)2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)10(dot ~4(at ~4 regs 1 rb)1 intVal)
)
)
),7(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 37(infix
 & ~24"opcCastPtrToInt\3A got " 2(prefix
 $ 9(dot ~4(at
 ~4 regs 1 rb
)1 kind)
)
)
)
)
)
)
)
),11(of
(curlyConstr 3 +2)2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(cast 5 int 18(dot
 ~4(at ~4 regs 1 rb)1 node
))
)
)
),13(else
 6(stmts (cmd
 assert 7 false 14(prefix $ 1 imm)
))
)
)
)
),62(of
(curlyConstr 3 opcCastIntToPtr)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let typ . . . 19(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 typ
))4,2(let
 node2 . . . 17(call
 ~9 newNodeIT 1 nkIntLit 18(at ~6(dot
 ~1 c 1 debug
)1 pc)24 typ
)
),3(case
 13(dot ~4(at ~4 regs 1 rb)1 kind),1(of
(curlyConstr
 3 rkInt
)10(stmts 13(asgn
 ~8(dot ~5 node2 1 intVal)10(dot ~4(at
 ~4 regs 1 rb
)1 intVal)
))
),2(of
(curlyConstr 3 rkNode)2,1(stmts
 (if
 3(elif
 23(infix
 notin ~6(dot ~4(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)1 kind)6 PtrLikeKinds
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 52(infix
 & ~39"opcCastIntToPtr\3A regs\5Brb\5D.node.typ\3A " 2(prefix
 $ 18(dot ~4(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)1 kind)
)
)
)
)
)
)13,2(asgn
 ~8(dot ~5 node2 1 intVal)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 intVal
)
)
)
),6(else
 6(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 48(infix
 & ~35"opcCastIntToPtr\3A regs\5Brb\5D.kind\3A " 2(prefix
 $ 9(dot ~4(at
 ~4 regs 1 rb
)1 kind)
)
)
)
)
)
)14,10(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 node2
)
)
),74(of
(curlyConstr 3 opcAsgnComplex)2,1(stmts
 11(call
 ~11 asgnComplex 5(at
 ~4 regs 1 ra
)15(at
 ~4 regs 6(dot ~5 instr 1 regB)
)
)
)
),76(of
(curlyConstr 3 opcFastAsgnComplex)2,1(stmts
 15(call
 ~15 fastAsgnComplex 5(at
 ~4 regs 1 ra
)15(at
 ~4 regs 6(dot ~5 instr 1 regB)
)
)
)
),78(of
(curlyConstr 3 opcAsgnRef)2,1(stmts
 7(call ~7 asgnRef 5(at
 ~4 regs 1 ra
)15(at
 ~4 regs 6(dot ~5 instr 1 regB)
))
)
),80(of
(curlyConstr 3 opcNodeToReg)2,1(stmts
 4(let ra . . . 10(dot
 ~5 instr 1 regA
))4,1(let rb . . . 10(dot
 ~5 instr 1 regB
)),4(if
 3(elif
 14(infix
 != ~6(dot ~4(at
 ~4 regs 1 rb
)1 kind)3 rkNode
)~1,1(stmts 9(asgn
 ~5(at ~4 regs 1 ra)6(at ~4 regs 1 rb)
))
),2(else
 2,1(stmts
 (cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)
)4,1(let nb . . . 13(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(case
 7(dot
 ~2 nb 1 kind
),1(of
(curlyConstr
 12(infix .. ~9 nkCharLit 2 nkUInt64Lit)
)2,1(stmts
 10(call ~10 ensureKind 1 rkInt)16,1(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)4(dot ~2 nb 1 intVal)
)
)
),4(of
(curlyConstr
 13(infix .. ~10 nkFloatLit 2 nkFloat64Lit)
)2,1(stmts
 10(call ~10 ensureKind 1 rkFloat)18,1(asgn ~10(dot ~4(at
 ~4 regs 1 ra
)1 floatVal)4(dot
 ~2 nb 1 floatVal
))
)
),7(else
 2,1(stmts
 10(call ~10 ensureKind 1 rkNode)14,1(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 nb
)
)
)
)
)
)
)
)
),100(of
(curlyConstr 3 opcSlice)2,3(stmts
 8(call
 ~8 decodeBC 1 rkNode
)2,2(let collection . . . 21(dot
 ~4(at ~4 regs 1 ra)1 node
))2,3(let
 leftInd . . . 18(dot ~4(at
 ~4 regs 1 rb
)1 intVal)
)2,4(let rightInd . . . 19(dot
 ~4(at ~4 regs 1 rc)1 intVal
)),6(proc
 5 rangeCheck . . . 15(params
 . 1(param
 left . . 13 BiggestInt .
)7(param right . . 7 BiggestInt .)26(param
 safeLen . . 9 BiggestInt .
)
). . 2,1(stmts
 (if
 3(elif
 5(infix < ~5 left 2 +0)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 left 7 safeLen
)
)
)
)
),3(if
 3(elif
 6(infix > ~6 right 2 safeLen)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 right 8 safeLen
)
)
)
)
)
)
),13(case
 15(dot ~10 collection 1 kind),1(of
(curlyConstr
 3 nkTupleConstr
)2,1(stmts
 4(let
 safeLen . . . 31(infix
 - ~8(dot
 ~3(at ~10 collection 1 +2)1 intVal
)15(dot
 ~3(at ~10 collection 1 +1)1 intVal
)
)
)10,1(call
 ~10 rangeCheck 1 leftInd 10 rightInd 20 safeLen
)2,3(let
 leftInd . . . 18(infix + ~8 leftInd 15(dot
 ~3(at ~10 collection 1 +1)1 intVal
))
)2,4(let
 rightInd . . . 20(infix
 + ~9 rightInd 15(dot ~3(at
 ~10 collection 1 +1
)1 intVal)
)
)14,6(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)9(call
 ~7 newTree ~21,1 nkTupleConstr ~11,2(at
 ~10 collection 1 +0
)~11,3(call ~10 newIntNode 1 nkIntLit 22(cmd
 ~11 BiggestInt leftInd
))~11,4(call ~10 newIntNode 1 nkIntLit 22(cmd
 ~11 BiggestInt rightInd
))
)
)
)
),15(else
 2,1(stmts
 4(let
 safeLen . . . 33(infix - ~13(call
 ~10 safeArrLen 1 collection
)2 +1)
)10,1(call
 ~10 rangeCheck 1 leftInd 10 rightInd 20 safeLen
)14,2(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)9(call
 ~7 newTree ~21,1 nkTupleConstr ~21,2 collection ~11,3(call ~10 newIntNode 1 nkIntLit 22(cmd
 ~11 BiggestInt leftInd
))~11,4(call ~10 newIntNode 1 nkIntLit 22(cmd
 ~11 BiggestInt rightInd
))
)
)
)
)
)
)
),142(of
(curlyConstr 3 opcLdArr)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNode
),1(if
 3(elif
 16(infix
 > ~8(dot
 ~4(at ~4 regs 1 rc)1 intVal
)6(call ~4 high 1 int)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 9(dot ~4(at
 ~4 regs 1 rc
)1 intVal)22(call ~4 high 1 int)
)
)
)
)
)4,3(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)4,4(let src . . . 14(dot
 ~4(at ~4 regs 1 rb)1 node
)),5(case
 8(dot
 ~3 src 1 kind
),1(of
(curlyConstr 3 nkTupleConstr)2,1(stmts
 2,1(let
 left . . . 13(dot ~3(at
 ~3 src 1 +1
)1 intVal)
)2,2(let right . . . 14(dot
 ~3(at ~3 src 1 +2)1 intVal
))2,3(let realIndex . . . 17(infix
 + ~5 left 2 idx
)),4(if
 3(elif
 4(infix in ~4 idx 4(infix
 .. ~1 +0 2(par 7(infix
 - ~6 right 2 left
))
))~1,1(stmts
 (case
 11(dot ~3(at
 ~3 src 1 +0
)1 kind),1(of
(curlyConstr 3 nkStrKinds)2,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)13(call
 ~10 newIntNode 1 nkCharLit 16(cmd ~4 ord 13(at
 ~7(dot ~3(at
 ~3 src 1 +0
)1 strVal)5(cmd ~4 int realIndex)
))
)
)
)
),3(of
(curlyConstr 3 nkBracket)2,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)8(at ~3(at ~3 src 1 +0)5(cmd
 ~4 int realIndex
))
)
)
),5(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"opcLdArr internal error"
))
)
)
)
),8(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call ~21 formatErrorIndexBound 1 idx 10(cmd
 ~4 int right
))
)
)
)
)
)
),17(of
(curlyConstr
 11(infix .. ~8 nkStrLit 2 nkTripleStrLit)
)2,1(stmts
 (if
 3(elif
 4(infix <% ~4 idx 13(dot
 ~7(dot ~3 src 1 strVal)1 len
))~1,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)10(call
 ~8 newNodeI 1 nkCharLit 19(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)21,1(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 intVal)17(dot
 ~5(at ~7(dot
 ~3 src 1 strVal
)1 idx)1 ord
)
)
)
),3(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 20(infix
 - ~4(dot ~7(dot
 ~3 src 1 strVal
)1 len)1 +1
)
)
)
)
)
)
)
),23(elif
 45(infix
 and ~31(infix
 notin ~6(dot ~3 src 1 kind)6(curlyConstr 8(infix
 .. ~7 nkEmpty 2 nkFloat128Lit
))
)8(infix
 <% ~4 idx 6(dot ~3 src 1 len)
)
)2,1(stmts 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)5(at ~3 src 1 idx)
))
),25(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 17(infix - ~8(dot
 ~3 src 1 safeLen
)1 +1)
)
)
)
)
)
)
),176(of
(curlyConstr 3 opcLdArrAddr)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNodeAddr
),1(if
 3(elif
 16(infix
 > ~8(dot
 ~4(at ~4 regs 1 rc)1 intVal
)6(call ~4 high 1 int)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 9(dot ~4(at
 ~4 regs 1 rc
)1 intVal)22(call ~4 high 1 int)
)
)
)
)
)4,3(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)4,4(let
 src . . . 6(if
 3(elif
 14(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)25(stmts
 8(dot ~4(at
 ~4 regs 1 rb
)1 node)
)
)42(else 6(stmts
 17(at ~9(dot
 ~4(at ~4 regs 1 rb)1 nodeAddr
))
))
)
),5(case
 8(dot ~3 src 1 kind),1(of
(curlyConstr
 3 nkTupleConstr
)2,1(stmts
 2,1(let left . . . 13(dot
 ~3(at ~3 src 1 +1)1 intVal
))2,2(let
 right . . . 14(dot ~3(at
 ~3 src 1 +2
)1 intVal)
)2,3(let
 realIndex . . . 17(infix + ~5 left 2 idx)
),4(if
 3(elif
 4(infix
 in ~4 idx 4(infix .. ~1 +0 2(par
 7(infix - ~6 right 2 left)
))
)~1,1(stmts
 (case
 11(dot ~3(at ~3 src 1 +0)1 kind),1(of
(curlyConstr
 3 nkStrKinds
)2,1(stmts
 9(asgn
 ~5(at ~4 regs 1 ra)17(call
 ~15 takeCharAddress 1 c 7(at
 ~3 src 1 +0
)12 realIndex 23 pc
)
)
)
),3(of
(curlyConstr 3 nkBracket)2,1(stmts
 (cmd
 takeAddress 16(at
 ~4 regs 1 ra
)38(at ~5(dot
 ~3(at ~5(dot ~3 src 1 sons)1 +0)1 sons
)1 realIndex)
)
)
),5(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"opcLdArrAddr internal error"
))
)
)
)
),8(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call ~21 formatErrorIndexBound 1 idx 10(cmd
 ~4 int right
))
)
)
)
)
)
),16(else
 2,1(stmts
 (if
 3(elif
 41(infix
 and ~32(infix
 notin ~6(dot ~3 src 1 kind)6(curlyConstr 8(infix
 .. ~7 nkEmpty 2 nkTripleStrLit
))
)8(infix
 <% ~4 idx 6(dot ~3 src 1 len)
)
)~1,1(stmts (cmd
 takeAddress 16(at ~4 regs 1 ra)30(at ~5(dot
 ~3 src 1 sons
)1 idx)
))
)5,2(elif
 23(infix
 and ~14(infix
 in ~6(dot ~3 src 1 kind)3 nkStrKinds
)8(infix <% ~4 idx 13(dot
 ~7(dot ~3 src 1 strVal)1 len
))
)~3,1(stmts
 9(asgn ~5(at ~4 regs 1 ra)17(call
 ~15 takeCharAddress 1 c 4 src 9 idx 14 pc
))
)
),4(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 17(infix - ~8(dot
 ~3 src 1 safeLen
)1 +1)
)
)
)
)
)
)
)
)
)
),206(of
(curlyConstr 3 opcLdStrIdx)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)6,2(let
 ~2 s . (pragmas 2 cursor). 26(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)
),3(if
 3(elif
 4(infix
 <% ~4 idx 4(dot ~1 s 1 len)
)~1,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)8(dot ~5(at ~1 s 1 idx)1 ord)
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 11(infix - ~4(dot
 ~1 s 1 len
)1 +1)
)
)
)
)
)
)
),214(of
(curlyConstr 3 opcLdStrIdxAddr)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNode
),1(if
 3(elif
 16(infix
 > ~8(dot
 ~4(at ~4 regs 1 rc)1 intVal
)6(call ~4 high 1 int)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 9(dot ~4(at
 ~4 regs 1 rc
)1 intVal)22(call ~4 high 1 int)
)
)
)
)
)4,3(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)4,4(let s . . . 24(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)1 addr
)),5(if
 3(elif
 4(infix <% ~4 idx 6(dot ~2(at
 ~1 s
)1 len))~1,1(stmts
 9(asgn
 ~5(at
 ~4 regs 1 ra
)17(call
 ~15 takeCharAddress 1 c 12(dot
 ~4(at ~4 regs 1 rb)1 node
)19 idx 24 pc
)
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 13(infix - ~4(dot ~2(at
 ~1 s
)1 len)1 +1)
)
)
)
)
)
)
),225(of
(curlyConstr 3 opcWrArr)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
),2(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 ra)1 kind
)3 rkNode)
)4,3(let arr . . . 14(dot
 ~4(at ~4 regs 1 ra)1 node
)),4(case
 8(dot
 ~3 arr 1 kind
),1(of
(curlyConstr 3 nkTupleConstr)2,1(stmts
 2,1(let src . . . 9(at
 ~3 arr 1 +0
))2,2(let left . . . 13(dot
 ~3(at ~3 arr 1 +1)1 intVal
))2,3(let
 right . . . 14(dot ~3(at
 ~3 arr 1 +2
)1 intVal)
)2,4(let
 realIndex . . . 17(infix + ~5 left 2 idx)
),5(if
 3(elif
 4(infix
 in ~4 idx 4(infix .. ~1 +0 2(par
 7(infix - ~6 right 2 left)
))
)~1,1(stmts
 (case
 8(dot ~3 src 1 kind),1(of
(curlyConstr 3 nkStrKinds)2,1(stmts
 27(asgn
 ~17(at
 ~7(dot
 ~3 src 1 strVal
)4(call ~3 int 1 realIndex)
)6(call ~4 char 9(dot
 ~4(at ~4 regs 1 rc)1 intVal
))
)
)
),3(of
(curlyConstr 3 nkBracket)2,1(stmts
 (if
 3(elif
 14(infix
 == ~6(dot ~4(at
 ~4 regs 1 rc
)1 kind)3 rkInt
)~1,1(stmts
 20(asgn
 ~17(at
 ~3 src 4(call ~3 int 1 realIndex)
)12(call ~10 newIntNode 1 nkIntLit 19(dot
 ~4(at ~4 regs 1 rc)1 intVal
))
)
)
),2(else
 2,1(stmts
 (cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rc)1 kind
)3 rkNode)
)20,1(asgn
 ~17(at
 ~3 src 4(call ~3 int 1 realIndex)
)10(dot ~4(at ~4 regs 1 rc)1 node)
)
)
)
)
)
),9(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"opcWrArr internal error"
))
)
)
)
),12(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call ~21 formatErrorIndexBound 1 idx 10(cmd
 ~4 int right
))
)
)
)
)
)
),21(of
(curlyConstr 3(curlyConstr
 9(infix .. ~8 nkStrLit 2 nkTripleStrLit)
))2,1(stmts
 (if
 3(elif
 4(infix
 <% ~4 idx 13(dot ~7(dot
 ~3 arr 1 strVal
)1 len)
)~1,1(stmts
 16(asgn
 ~6(at
 ~7(dot ~3 arr 1 strVal)1 idx
)5(call ~3 chr 9(dot
 ~4(at ~4 regs 1 rc)1 intVal
))
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 20(infix
 - ~4(dot ~7(dot
 ~3 arr 1 strVal
)1 len)1 +1
)
)
)
)
)
)
)
),26(elif
 9(infix
 <% ~4 idx 6(dot ~3 arr 1 len)
)2,1(stmts
 10(call ~10 writeField 4(at ~3 arr 1 idx)15(at
 ~4 regs 1 rc
))
)
),28(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 17(infix - ~8(dot
 ~3 arr 1 safeLen
)1 +1)
)
)
)
)
)
)
),261(of
(curlyConstr 3 opcLdObj)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 src . . . 6(if
 3(elif
 14(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)25(stmts
 8(dot ~4(at
 ~4 regs 1 rb
)1 node)
)
)42(else 6(stmts
 17(at ~9(dot
 ~4(at ~4 regs 1 rb)1 nodeAddr
))
))
)
),2(case
 8(dot ~3 src 1 kind),1(of
(curlyConstr 10(infix
 .. ~7 nkEmpty 2 nkNilLit
))2,4(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 32(infix
 & ~6(infix
 & ~13 errNilAccess 2" "
)2(prefix
 $ 1(tupleConstr
 1"kind" 12(dot ~3 src 1 kind)19"typ" 38(call ~12 typeToString 4(dot
 ~3 src 1 typ
))49"rc" 55 rc
)
)
)
)
)
),6(of
(curlyConstr 3 nkObjConstr)2,1(stmts
 4(let n . . . 15(dot
 ~8(at ~3 src 4(infix
 + ~3 rc 2 +1
))1 skipColon
))14,1(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 n
)
)
),9(of
(curlyConstr 3 nkTupleConstr)2,1(stmts
 4(let
 n . . . 4(if
 3(elif
 15(infix
 and ~7(infix != ~5(dot
 ~3 src 1 typ
)3(nil))26(infix
 in ~22 tfTriggersCompileTime 10(dot ~4(dot
 ~3 src 1 typ
)1 flags)
)
)~7,1(stmts 3(at ~3 src 1 rc))
)~6,2(else
 2,1(stmts 7(dot
 ~4(at ~3 src 1 rc)1 skipColon
))
)
)
)14,4(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 n
)
)
),15(else
 2,1(stmts
 4(let n . . . 7(at ~3 src 1 rc))14,1(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 n
)
)
)
)
)
),283(of
(curlyConstr 3 opcLdObjAddr)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNodeAddr
)4,1(let
 src . . . 6(if
 3(elif
 14(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)25(stmts
 8(dot ~4(at
 ~4 regs 1 rb
)1 node)
)
)42(else 6(stmts
 17(at ~9(dot
 ~4(at ~4 regs 1 rb)1 nodeAddr
))
))
)
),2(case
 8(dot ~3 src 1 kind),1(of
(curlyConstr 10(infix
 .. ~7 nkEmpty 2 nkNilLit
))2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
),3(of
(curlyConstr 3 nkObjConstr)2,1(stmts
 4(let n . . . 12(at
 ~5(dot
 ~3 src 1 sons
)4(infix + ~3 rc 2 +1)
)),1(if
 3(elif
 7(infix == ~6(dot
 ~1 n 1 kind
)3 nkExprColonExpr)~1,1(stmts (cmd
 takeAddress 16(at
 ~4 regs 1 ra
)28(at ~5(dot ~1 n 1 sons)1 +1)
))
),2(else
 2,1(stmts
 (cmd
 takeAddress 16(at ~4 regs 1 ra)30(at
 ~5(dot
 ~3 src 1 sons
)4(infix + ~3 rc 2 +1)
)
)
)
)
)
)
),9(else
 2,1(stmts (cmd
 takeAddress 16(at ~4 regs 1 ra)30(at ~5(dot
 ~3 src 1 sons
)1 rc)
))
)
)
)
),298(of
(curlyConstr 3 opcWrObj)2,2(stmts
 8(call
 ~8 decodeBC 1 rkNode
),1(cmd
 assert 21(infix != ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)3(nil))
)4,2(let
 shiftedRb . . . 15(infix
 + ~3 rb 5(call
 ~3 ord 20(infix
 == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 kind
)3 nkObjConstr
)
)
)
)4,3(let dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),4(if
 3(elif
 10(infix == ~6(dot
 ~4 dest 1 kind
)3 nkNilLit)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
)5,2(elif
 21(infix
 == ~6(dot
 ~11(at ~4 dest 1 shiftedRb)1 kind
)3 nkExprColonExpr
)~3,1(stmts
 10(call
 ~10 writeField 16(at
 ~11(at ~4 dest 1 shiftedRb)1 +1
)25(at ~4 regs 1 rc)
)
)
),4(else
 2,1(stmts
 10(call ~10 writeField 5(at ~4 dest 1 shiftedRb)22(at
 ~4 regs 1 rc
))
)
)
)
)
),310(of
(curlyConstr 3 opcWrStrIdx)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
),2(if
 3(elif
 4(infix
 <% ~4 idx 23(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)1 len
)
)~1,1(stmts
 26(asgn
 ~6(at
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)1 idx
)5(call ~3 chr 9(dot
 ~4(at ~4 regs 1 rc)1 intVal
))
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 30(infix
 - ~4(dot ~7(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)1 len)1 +1
)
)
)
)
)
)
)
),317(of
(curlyConstr 3 opcAddrReg)2,1(stmts
 7(call
 ~7 decodeB 1 rkRegisterAddr
)17,1(asgn
 ~9(dot
 ~4(at ~4 regs 1 ra)1 regAddr
)6(call ~4 addr 5(at ~4 regs 1 rb))
)
)
),320(of
(curlyConstr 3 opcAddrNode)2,1(stmts
 7(call
 ~7 decodeB 1 rkNodeAddr
),1(case
 13(dot ~4(at ~4 regs 1 rb)1 kind),1(of
(curlyConstr
 3 rkNode
)2,1(stmts (cmd
 takeAddress 16(at ~4 regs 1 ra)30(dot ~4(at
 ~4 regs 1 rb
)1 node)
))
),3(of
(curlyConstr 3 rkNodeAddr)2,1(stmts
 18(asgn
 ~10(dot ~4(at
 ~4 regs 1 ra
)1 nodeAddr)10(dot ~4(at
 ~4 regs 1 rb
)1 nodeAddr)
)
)
),5(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 57(infix
 & ~44"limited VM support for \27addr\27, got kind\3A " 2(prefix
 $ 9(dot ~4(at
 ~4 regs 1 rb
)1 kind)
)
)
)
)
)
)
)
),329(of
(curlyConstr 3 opcLdDeref)2,2(stmts
 4(let ra . . . 10(dot
 ~5 instr 1 regA
))4,1(let rb . . . 10(dot
 ~5 instr 1 regB
)),2(case
 13(dot
 ~4(at ~4 regs 1 rb)1 kind
),1(of
(curlyConstr 3 rkNodeAddr)2,1(stmts
 10(call
 ~10 ensureKind 1 rkNode
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)19(at
 ~9(dot ~4(at
 ~4 regs 1 rb
)1 nodeAddr)
)
)
)
),4(of
(curlyConstr 3 rkRegisterAddr)2,1(stmts
 10(call ~10 ensureKind 17(dot
 ~8(dot ~4(at
 ~4 regs 1 rb
)1 regAddr)1 kind
))9,1(asgn
 ~5(at
 ~4 regs 1 ra
)18(at ~8(dot
 ~4(at ~4 regs 1 rb)1 regAddr
))
)
)
),7(of
(curlyConstr 3 rkNode)2,1(stmts
 (if
 3(elif
 19(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkRefTy)~1,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)15(at ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 +0)
)
)
)5,2(elif
 (prefix
 not 18(call
 ~14 maybeHandlePtr 9(dot
 ~4(at ~4 regs 1 rb)1 node
)20(at ~4 regs 1 ra)26 false
)
)~3,1(stmts
 (comment)10,1(call ~10 ensureKind 1 rkNode)14,2(asgn ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)10(dot
 ~4(at ~4 regs 1 rb)1 node
))
)
)
)
)
),14(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 38(infix
 & ~12(infix
 & ~13 errNilAccess 2" kind\3A "
)2(prefix
 $ 9(dot ~4(at ~4 regs 1 rb)1 kind)
)
)
)
)
)
)
)
),349(of
(curlyConstr 3 opcWrDeref)2,2(stmts
 4(let ra . . . 10(dot
 ~5 instr 1 regA
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
)),2(case
 13(dot
 ~4(at ~4 regs 1 ra)1 kind
),1(of
(curlyConstr 3 rkNodeAddr)2,1(stmts
 4(let
 n . . . 12(dot ~4(at
 ~4 regs 1 rc
)1 regToNode)
)4,5(let nAddr . . . 16(dot
 ~4(at ~4 regs 1 ra)1 nodeAddr
)),6(if
 3(elif
 8(infix == ~3(at
 ~5 nAddr
)3(nil))16(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"opcWrDeref internal error"
))
)
),7(if
 3(elif
 (par
 29(infix
 and ~20(infix notin ~8 nfIsRef 13(dot
 ~2(at ~5 nAddr)1 flags
))12(infix notin ~8 nfIsRef 7(dot
 ~1 n 1 flags
))
)
)57(stmts 10(asgn
 ~3(at ~2(at ~5 nAddr))3(at ~1 n)
))
),1(else 6(stmts
 8(asgn ~3(at ~5 nAddr)2 n)
))
)
)
),11(of
(curlyConstr 3 rkRegisterAddr)19(stmts
 19(asgn
 ~3(at
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 regAddr)
)6(at ~4 regs 1 rc)
)
)
),12(of
(curlyConstr 3 rkNode)2,2(stmts
 (if
 3(elif
 (prefix
 not 18(call
 ~14 maybeHandlePtr 9(dot ~4(at
 ~4 regs 1 ra
)1 node)20(at ~4 regs 1 rc)26 true
)
)~1,1(stmts
 16(asgn
 ~3(at ~5(dot
 ~4(at ~4 regs 1 ra)1 node
))20(at
 ~10(dot ~4(at
 ~4 regs 1 rc
)1 regToNode)
)
)19,1(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
)
)
)
),17(else
 6(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
)
)
)
),371(of
(curlyConstr 3 opcAddInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)2,2(let bVal . . . 15(dot
 ~4(at ~4 regs 1 rb)1 intVal
))2,3(let
 cVal . . . 15(dot ~4(at
 ~4 regs 1 rc
)1 intVal)
)2,4(let
 sum . . . 11(infix +% ~5 bVal 3 cVal)
),5(if
 3(elif
 20(infix
 or ~5(infix >= ~15(par
 5(infix xor ~4 sum 4 bVal)
)3 +0)18(infix
 >= ~15(par 5(infix
 xor ~4 sum 4 cVal
))3 +0
)
)~1,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 sum)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),381(of
(curlyConstr 3 opcAddImmInt)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
)2,4(let bVal . . . 15(dot
 ~4(at ~4 regs 1 rb)1 intVal
))2,5(let
 cVal . . . 7 imm
)2,6(let
 sum . . . 11(infix +% ~5 bVal 3 cVal)
),7(if
 3(elif
 20(infix
 or ~5(infix >= ~15(par
 5(infix xor ~4 sum 4 bVal)
)3 +0)18(infix
 >= ~15(par 5(infix
 xor ~4 sum 4 cVal
))3 +0
)
)~1,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 sum)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),393(of
(curlyConstr 3 opcSubInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)2,2(let bVal . . . 15(dot
 ~4(at ~4 regs 1 rb)1 intVal
))2,3(let
 cVal . . . 15(dot ~4(at
 ~4 regs 1 rc
)1 intVal)
)2,4(let
 diff . . . 12(infix -% ~5 bVal 3 cVal)
),5(if
 3(elif
 21(infix
 or ~5(infix >= ~16(par
 6(infix xor ~5 diff 4 bVal)
)3 +0)23(infix >= ~20(par
 6(infix xor ~5 diff 4(prefix
 not 4 cVal
))
)3 +0)
)~1,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 diff)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),403(of
(curlyConstr 3 opcSubImmInt)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
)2,2(let bVal . . . 15(dot
 ~4(at ~4 regs 1 rb)1 intVal
))2,3(let
 cVal . . . 7 imm
)2,4(let
 diff . . . 12(infix -% ~5 bVal 3 cVal)
),5(if
 3(elif
 21(infix
 or ~5(infix >= ~16(par
 6(infix xor ~5 diff 4 bVal)
)3 +0)23(infix >= ~20(par
 6(infix xor ~5 diff 4(prefix
 not 4 cVal
))
)3 +0)
)~1,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 diff)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),413(of
(curlyConstr 3 opcLenSeq)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
)2,3(let high . . . 7(par
 5(infix and ~4 imm 4 +1)
))2,4(let
 node . . . 15(dot ~4(at
 ~4 regs 1 rb
)1 node)
),5(if
 3(elif
 22(infix != ~22(par
 5(infix and ~4 imm 4 nimNodeFlag)
)3 +0)~1,2(stmts
 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)24(infix - ~9(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 safeLen
)2 high)
)
)
),3(else
 2,1(stmts
 (case
 9(dot ~4 node 1 kind),1(of
(curlyConstr
 3 nkTupleConstr
)2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)38(infix
 - ~4(infix
 + ~17(infix
 - ~8(dot
 ~3(at ~4 node 1 +2)1 intVal
)9(dot ~3(at ~4 node 1 +1)1 intVal)
)2 +1
)2 high
)
)
)
),3(else
 2,3(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 - ~12(dot ~4 node 1 safeArrLen)2 high
)
)
)
)
)
)
)
)
)
),431(of
(curlyConstr 3 opcLenStr)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)27(infix
 - ~5(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)1 len
)2 imm
)
)
)
),435(of
(curlyConstr 3 opcLenCstring)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)
),2(if
 3(elif
 19(infix
 == ~6(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 kind)3 nkNilLit
)~1,1(stmts 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(prefix - 1 imm)
))
),2(else
 2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)35(infix
 - ~5(dot
 ~8(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)1 cstring
)1 len
)2 imm
)
)
)
)
)
)
),442(of
(curlyConstr 3 opcIncl)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let b . . . 12(dot
 ~4(at ~4 regs 1 rb)1 regToNode
)),2(if
 3(elif
 (prefix not 9(call
 ~5 inSet 9(dot ~4(at
 ~4 regs 1 ra
)1 node)16 b
))~1,1(stmts
 13(cmd
 (dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 add
)13(call ~8 copyTree 1 b)
)
)
)
)
)
),447(of
(curlyConstr 3 opcInclRange)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(var
 r . . . 11(call ~7 newNode 1 nkRange)
)1,2(cmd (dot ~1 r 1 add)13(dot
 ~4(at ~4 regs 1 rb)1 regToNode
))1,3(cmd (dot
 ~1 r 1 add
)13(dot
 ~4(at ~4 regs 1 rc)1 regToNode
))13,4(cmd
 (dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 add
)6(dot ~1 r 1 copyTree)
)
)
),453(of
(curlyConstr 3 opcExcl)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var
 b . . . 13(call
 ~9 newNodeIT 1 nkCurly 23(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)43(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 typ
)
)
)1,2(cmd (dot ~1 b 1 add)13(dot
 ~4(at ~4 regs 1 rb)1 regToNode
))4,3(var
 r . . . 12(call
 ~8 diffSets 2(dot
 ~1 c 1 config
)19(dot ~4(at ~4 regs 1 ra)1 node)26 b
)
)11,4(call ~11 discardSons 9(dot
 ~4(at ~4 regs 1 ra)1 node
))4,5(for
 6(infix ..< ~1 +0 4(dot
 ~1 r 1 len
))(unpackIntoFlat(let i ....))16(stmts 13(cmd
 (dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 add
)6(at ~1 r 1 i)
))
)
)
),460(of
(curlyConstr 3 opcCard)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)17(call
 ~8(dot ~7 nimsets 1 cardSet)2(dot
 ~1 c 1 config
)19(dot ~4(at ~4 regs 1 rb)1 node)
)
)
)
),463(of
(curlyConstr 3 opcMulInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)2,2(let bVal . . . 15(dot
 ~4(at ~4 regs 1 rb)1 intVal
))2,3(let
 cVal . . . 15(dot ~4(at
 ~4 regs 1 rc
)1 intVal)
)2,4(let
 product . . . 15(infix *% ~5 bVal 3 cVal)
)2,5(let
 floatProd . . . 33(infix
 * ~7(call
 ~14 toBiggestFloat 1 bVal
)16(call ~14 toBiggestFloat 1 cVal)
)
)2,6(let resAsFloat . . . 27(call
 ~14 toBiggestFloat 1 product
)),7(if
 3(elif
 11(infix
 == ~11 resAsFloat 3 floatProd
)~1,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 product)
)
)5,2(elif
 35(infix
 <= ~30(infix
 * ~5 +32.0 5(call ~3 abs 12(infix
 - ~11 resAsFloat 2 floatProd
))
)6(call ~3 abs 1 floatProd)
)~3,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 product)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),477(of
(curlyConstr 3 opcDivInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
),1(if
 3(elif
 16(infix == ~8(dot
 ~4(at ~4 regs 1 rc)1 intVal
)3 +0)22(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errConstantDivisionByZero
))
),1(else
 6(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 div ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
)
)
),481(of
(curlyConstr 3 opcModInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
),1(if
 3(elif
 16(infix == ~8(dot
 ~4(at ~4 regs 1 rc)1 intVal
)3 +0)22(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errConstantDivisionByZero
))
),1(else
 6(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 mod ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
)
)
),485(of
(curlyConstr 3 opcAddFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkFloat
)18,1(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)20(infix
 + ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
),488(of
(curlyConstr 3 opcSubFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkFloat
)18,1(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)20(infix
 - ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
),491(of
(curlyConstr 3 opcMulFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkFloat
)18,1(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)20(infix
 * ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
),494(of
(curlyConstr 3 opcDivFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkFloat
)18,1(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)20(infix
 / ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
),497(of
(curlyConstr 3 opcShrInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let
 b . . . 4(cast 5 uint64 21(dot
 ~4(at ~4 regs 1 rb)1 intVal
))
)4,2(let
 c . . . 4(cast 5 uint64 21(dot
 ~4(at ~4 regs 1 rc)1 intVal
))
)4,3(let a . . . 4(cast
 5 int64 14(infix shr ~2 b 4 c)
))16,4(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)2 a
)
)
),503(of
(curlyConstr 3 opcShlInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 shl ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),506(of
(curlyConstr 3 opcAshrInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)6(call
 ~4 ashr 9(dot
 ~4(at ~4 regs 1 rb)1 intVal
)26(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),509(of
(curlyConstr 3 opcBitandInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 and ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),512(of
(curlyConstr 3 opcBitorInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 or ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),515(of
(curlyConstr 3 opcBitxorInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 xor ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),518(of
(curlyConstr 3 opcAddu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 +% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),521(of
(curlyConstr 3 opcSubu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 -% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),524(of
(curlyConstr 3 opcMulu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 *% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),527(of
(curlyConstr 3 opcDivu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 /% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),530(of
(curlyConstr 3 opcModu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 %% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
),533(of
(curlyConstr 3 opcEqInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 == ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),536(of
(curlyConstr 3 opcLeInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 <= ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),539(of
(curlyConstr 3 opcLtInt)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 < ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)10(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),542(of
(curlyConstr 3 opcEqFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 19(infix
 == ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)11(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
)
),545(of
(curlyConstr 3 opcLeFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 19(infix
 <= ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)11(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
)
),548(of
(curlyConstr 3 opcLtFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 19(infix
 < ~10(dot
 ~4(at ~4 regs 1 rb)1 floatVal
)10(dot
 ~4(at ~4 regs 1 rc)1 floatVal
)
)
)
)
)
),551(of
(curlyConstr 3 opcLeu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 <=% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)12(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),554(of
(curlyConstr 3 opcLtu)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 <% ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),557(of
(curlyConstr 3 opcEqRef)2,1(stmts
 4(var
 ret . . . 6 false
)8,1(call ~8 decodeBC 1 rkInt),2(template
 9 getTyp . . . 15(params 5 untyped 1(param
 n . . . .
)). . 2,1(stmts 15(call
 ~10(dot ~4(dot
 ~1 n 1 typ
)1 skipTypes)1 abstractInst
))
),4(template
 9 skipRegisterAddr . . . 25(params 15 TFullReg 1(param
 n . . 3 TFullReg .
)). . 2,1(stmts
 4(var
 tmp . . . 6 n
),1(while
 15(infix
 == ~6(dot ~3 tmp 1 kind)3 rkRegisterAddr
)2,1(stmts
 4(asgn ~4 tmp 13(at
 ~8(dot ~3 tmp 1 regAddr)
))
)
),3 tmp
)
),10(proc
 5 ptrEquality . . . 16(params
 28 bool 1(param
 n1 . . 4(ptr 4 PNode).
)16(param n2 . . 4 PNode .)
). . 2,1(stmts
 (comment)4,1(let
 p1 . . . 5(cast 5 int 10 n1)
),2(case
 7(dot ~2 n2 1 kind),1(of
(curlyConstr 3 nkNilLit)13(stmts (ret 10(infix
 == ~3 p1 3 +0
)))
),2(of
(curlyConstr 3 nkIntLit)2,4(stmts
 4(let t2 . . . 7(dot
 ~2 n2 1 getTyp
)),1(ret
 31(infix
 and ~16(infix in ~6(dot
 ~2 t2 1 kind
)3 PtrLikeKinds)14(infix == ~8(dot
 ~2 n2 1 intVal
)3 p1)
)
)
)
),8(else 6(stmts (ret 7 false)))
)
)
)4,23(let rbReg . . . 24(call
 ~16 skipRegisterAddr 5(at ~4 regs 1 rb)
))4,24(let
 rcReg . . . 24(call ~16 skipRegisterAddr 5(at
 ~4 regs 1 rc
))
),26(if
 3(elif
 11(infix
 == ~6(dot ~5 rbReg 1 kind)3 rkNodeAddr
)~1,1(stmts
 (if
 3(elif
 11(infix
 == ~6(dot ~5 rcReg 1 kind)3 rkNodeAddr
)~1,1(stmts
 4(asgn
 ~4 ret 17(infix == ~10(dot ~5 rbReg 1 nodeAddr)8(dot
 ~5 rcReg 1 nodeAddr
))
)
)
),2(else
 2,1(stmts
 4(asgn
 ~4 ret 13(call
 ~11 ptrEquality 6(dot
 ~5 rbReg 1 nodeAddr
)22(dot ~5 rcReg 1 node)
)
)
)
)
)
)
)5,5(elif
 11(infix
 == ~6(dot ~5 rcReg 1 kind)3 rkNodeAddr
)~3,1(stmts
 4(asgn
 ~4 ret 13(call ~11 ptrEquality 6(dot ~5 rcReg 1 nodeAddr)22(dot
 ~5 rbReg 1 node
))
)
)
),7(else
 2,1(stmts
 4(let
 nb . . . 10(dot ~5 rbReg 1 node)
)4,1(let
 nc . . . 10(dot ~5 rcReg 1 node)
),2(if
 3(elif
 8(infix
 != ~6(dot ~2 nb 1 kind)5(dot ~2 nc 1 kind)
)20(stmts (discard .))
)5,1(elif
 11(infix
 or ~11(par 4(infix == ~3 nb 3 nc))3(par
 9(infix == ~6(dot
 ~2 nb 1 kind
)3 nkNilLit)
)
)37(stmts 4(asgn ~4 ret 2 true))
)5,2(elif
 89(infix
 and ~26(infix
 and ~18(infix
 and ~37(infix
 in ~6(dot ~2 nb 1 kind)3(curlyConstr
 1 nkSym 8 nkTupleConstr 23 nkClosure
)
)11(infix != ~5(dot ~2 nb 1 typ)3(nil))
)16(infix
 == ~6(dot ~4(dot ~2 nb 1 typ)1 kind)3 tyProc
)
)16(call ~12 sameConstant 1 nb 5 nc)
)~3,1(stmts 4(asgn ~4 ret 2 true))
)5,5(elif
 44(infix
 and ~24(infix
 and ~12(infix
 == ~6(dot ~2 nb 1 kind)3 nkIntLit
)12(infix
 == ~6(dot ~2 nc 1 kind)3 nkIntLit
)
)14(infix
 == ~8(dot ~2 nb 1 intVal)5(dot ~2 nc 1 intVal)
)
)~3,1(stmts
 4(let
 tb . . . 7(dot ~2 nb 1 getTyp)
)4,1(let
 tc . . . 7(dot ~2 nc 1 getTyp)
)4,2(asgn
 ~4 ret 26(infix
 and ~16(infix
 in ~6(dot ~2 tb 1 kind)3 PtrLikeKinds
)12(infix
 == ~6(dot ~2 tc 1 kind)5(dot ~2 tb 1 kind)
)
)
)
)
)
)
)
)
)16,45(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call ~3 ord 1 ret)
)
)
),604(of
(curlyConstr 3 opcEqNimNode)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~11,1(call
 ~3 ord 25(call
 ~24 exprStructuralEquivalent 9(dot
 ~4(at ~4 regs 1 rb)1 node
)24(dot ~4(at ~4 regs 1 rc)1 node)18,1(vv
 ~17 strictSymEquality 1 true
)
)
)
)
)
),609(of
(curlyConstr 3 opcSameNodeType)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 32(call
 ~14(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)1 sameTypeOrNil
)14(dot
 ~5(dot ~4(at ~4 regs 1 rc)1 node)1 typ
)20(curlyConstr
 1 ExactTypeDescValues 22 ExactGenericParams
)
)
)
)
)
),613(of
(curlyConstr 3 opcXor)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 != ~8(dot
 ~4(at ~4 regs 1 rb)1 intVal
)11(dot ~4(at ~4 regs 1 rc)1 intVal)
)
)
)
)
),616(of
(curlyConstr 3 opcNot)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkInt)
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)4(infix - ~2 +1 10(dot
 ~4(at ~4 regs 1 rb)1 intVal
))
)
)
),620(of
(curlyConstr 3 opcUnaryMinusInt)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkInt)
)4,2(let val . . . 14(dot
 ~4(at ~4 regs 1 rb)1 intVal
)),3(if
 3(elif
 4(infix != ~4 val 8(dot
 ~5 int64 1 low
))~1,1(stmts 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)2(prefix - 1 val)
))
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errOverOrUnderflow
))
)
)
)
),628(of
(curlyConstr 3 opcUnaryMinusFloat)2,1(stmts
 7(call
 ~7 decodeB 1 rkFloat
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkFloat)
)18,2(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)2(prefix - 9(dot
 ~4(at ~4 regs 1 rb)1 floatVal
))
)
)
),632(of
(curlyConstr 3 opcBitnotInt)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
),1(cmd
 assert 21(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkInt)
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2(prefix not 12(dot
 ~4(at ~4 regs 1 rb)1 intVal
))
)
)
),636(of
(curlyConstr 3 opcEqStr)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 22(infix
 == ~8(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)16(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)
)
)
)
)
),639(of
(curlyConstr 3 opcEqCString)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let
 bNil . . . 26(infix
 == ~6(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 kind)3 nkNilLit
)
)4,2(let
 cNil . . . 26(infix
 == ~6(dot ~5(dot
 ~4(at ~4 regs 1 rc)1 node
)1 kind)3 nkNilLit
)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 17(infix
 or ~16(par
 6(infix and ~5 bNil 4 cNil)
)~36,1(par
 23(infix
 and ~13(infix and ~9(prefix not 4 bNil)4(prefix
 not 4 cNil
))25(infix
 == ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)16(dot
 ~5(dot ~4(at ~4 regs 1 rc)1 node)1 strVal
)
)
)
)
)
)
)
)
),645(of
(curlyConstr 3 opcLeStr)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 22(infix
 <= ~8(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)16(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)
)
)
)
)
),648(of
(curlyConstr 3 opcLtStr)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 22(infix
 < ~8(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)
)
)
)
)
),651(of
(curlyConstr 3 opcLeSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 13(call
 ~12 containsSets 2(dot ~1 c 1 config)19(dot ~4(at
 ~4 regs 1 rb
)1 node)34(dot
 ~4(at ~4 regs 1 rc)1 node
)
)
)
)
)
),654(of
(curlyConstr 3 opcEqSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 10(call
 ~9 equalSets 2(dot ~1 c 1 config)19(dot ~4(at
 ~4 regs 1 rb
)1 node)34(dot
 ~4(at ~4 regs 1 rc)1 node
)
)
)
)
)
),657(of
(curlyConstr 3 opcLtSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
))4,2(let
 b . . . 12(dot ~4(at
 ~4 regs 1 rc
)1 node)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 30(infix
 and ~17(call
 ~12 containsSets 2(dot ~1 c 1 config)11 a 14 b
)4(prefix not 13(call
 ~9 equalSets 2(dot ~1 c 1 config)11 a 14 b
))
)
)
)
)
),662(of
(curlyConstr 3 opcMulSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)9,1(call
 ~9 createSet 5(at ~4 regs 1 ra)
)4,2(call
 ~4 move 14(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 sons)63,1(dot
 ~40(call
 ~14(dot
 ~7 nimsets 1 intersectSets
)2(dot ~1 c 1 config)19(dot
 ~4(at ~4 regs 1 rb)1 node
)34(dot ~4(at ~4 regs 1 rc)1 node)
)1 sons
)
)
)
),667(of
(curlyConstr 3 opcPlusSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)9,1(call
 ~9 createSet 5(at ~4 regs 1 ra)
)4,2(call
 ~4 move 14(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 sons)58,1(dot
 ~40(call
 ~10(dot
 ~7 nimsets 1 unionSets
)2(dot ~1 c 1 config)19(dot
 ~4(at ~4 regs 1 rb)1 node
)34(dot ~4(at ~4 regs 1 rc)1 node)
)1 sons
)
)
)
),672(of
(curlyConstr 3 opcMinusSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)9,1(call
 ~9 createSet 5(at ~4 regs 1 ra)
)4,2(call
 ~4 move 14(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 sons)57,1(dot
 ~40(call
 ~9(dot
 ~7 nimsets 1 diffSets
)2(dot ~1 c 1 config)19(dot
 ~4(at ~4 regs 1 rb)1 node
)34(dot ~4(at ~4 regs 1 rc)1 node)
)1 sons
)
)
)
),677(of
(curlyConstr 3 opcConcatStr)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
),1(cmd createStr 14(at ~4 regs 1 ra))21,2(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)8(call ~6 getstr 5(at ~4 regs 1 rb))
)4,3(for
 9(infix
 .. ~2(infix + ~2 rb 1 +1)7(infix - ~3(infix
 + ~2 rb 1 rc
)1 +1)
)(unpackIntoFlat(let i ....))~2,1(stmts
 20(cmd
 (dot ~7(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)1 add)11(call ~6 getstr 5(at
 ~4 regs 1 i
))
)
)
)
)
),683(of
(curlyConstr 3 opcAddStrCh)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)24,1(call
 ~4(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)1 add
)16(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 chr)
)
)
),686(of
(curlyConstr 3 opcAddStrStr)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)24,1(call
 ~4(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)1 add
)14(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)
)
),689(of
(curlyConstr 3 opcAddSeqElem)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(if
 3(elif
 19(infix
 == ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 kind)3 nkBracket
)~1,1(stmts
 17(call
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 add)10(call
 ~9 copyValue 9(dot ~4(at
 ~4 regs 1 rb
)1 regToNode)
)
)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
)
)
)
),695(of
(curlyConstr 3 opcGetImpl)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkVarTy)19(stmts 2(asgn ~2 a 3(at
 ~1 a 1 +0
)))
)
),3(if
 3(elif
 7(infix
 == ~6(dot ~1 a 1 kind)3 nkSym
)~1,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)2(if
 3(elif
 9(dot
 ~4(dot ~4(dot ~1 a 1 sym)1 ast)1 isNil
)17(stmts
 7(call ~7 newNode 1 nkNilLit)
)
),1(else 6(stmts
 8(call ~8 copyTree 6(dot
 ~4(dot ~1 a 1 sym)1 ast
))
))
)
)19,2(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a symbol"
))
)
)
)
),705(of
(curlyConstr 3 opcGetImplTransf)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkSym)~1,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)~12,1(if
 3(elif
 9(dot
 ~4(dot ~4(dot
 ~1 a 1 sym
)1 ast)1 isNil
)~1,1(stmts
 7(call ~7 newNode 1 nkNilLit)
)
),2(else
 2,1(stmts
 4(let
 ast . . . 15(dot ~4(dot
 ~4(dot ~1 a 1 sym)1 ast
)1 shallowCopy)
)4,1(for
 6(infix
 ..< ~1 +0 12(dot ~4(dot
 ~4(dot ~1 a 1 sym)1 ast
)1 len)
)(unpackIntoFlat(let i ....))~2,1(stmts
 7(asgn ~4(at ~3 ast 1 i)11(at
 ~4(dot ~4(dot
 ~1 a 1 sym
)1 ast)1 i
))
)
)13,3(asgn
 ~10(at ~3 ast 1 bodyPos)15(call
 ~13 transformBody 2(dot
 ~1 c 1 graph
)11(dot ~1 c 1 idgen)20(dot ~1 a 1 sym)26(curlyConstr
 1 useCache 11 force
)
)
)12,4(call ~9(dot ~3 ast 1 copyTree))
)
)
)
)
)
)
)
)
),718(of
(curlyConstr 3 opcSymOwner)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkSym)~1,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2(if
 3(elif
 11(dot
 ~6(dot ~4(dot
 ~1 a 1 sym
)1 owner)1 isNil
)19(stmts
 7(call ~7 newNode 1 nkNilLit)
)
),1(else
 6(stmts
 10(call ~10 newSymNode 6(dot
 ~4(dot ~1 a 1 sym)1 skipGenericOwner
))
)
)
)
)19,2(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a symbol"
))
)
)
)
),727(of
(curlyConstr 3 opcSymIsInstantiationOf)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
))4,2(let
 b . . . 12(dot ~4(at
 ~4 regs 1 rc
)1 node)
),3(if
 3(elif
 16,1(infix
 and 30,-1(infix
 and ~30(infix
 and ~9(infix
 == ~6(dot ~1 a 1 kind)3 nkSym
)15(infix
 in ~6(dot ~4(dot ~1 a 1 sym)1 kind)3 skProcKinds
)
)~39,1(infix
 == ~6(dot ~1 b 1 kind)3 nkSym
)
)15(infix
 in ~6(dot ~4(dot ~1 b 1 sym)1 kind)3 skProcKinds
)
)~1,2(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~14,1(if
 3(elif
 29(infix
 and ~15(infix in ~14 sfFromGeneric 8(dot
 ~4(dot ~1 a 1 sym)1 flags
))27(infix == ~18(dot ~4(dot
 ~1 a 1 sym
)1 instantiatedFrom)4(dot
 ~1 b 1 sym
))
)66(stmts +1)
),1(else 6(stmts +0))
)
)
)
),5(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a proc symbol"
))
)
)
)
),738(of
(curlyConstr 3 opcEcho)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
)),1(template
 9 fn . . . 11(params . 1(param
 s . . . .
)). . 17(stmts
 10(call
 ~10 msgWriteln 2(dot
 ~1 c 1 config
)11 s 14(curlyConstr 1 msgStdout 12 msgNoUnitSep)
)
)
),2(if
 3(elif
 3(infix == ~3 rb 3 +1)9(stmts
 2(call ~2 fn 14(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
))
)
),1(else
 2,1(stmts
 4(var outp . . . 7"")4,1(for
 7(infix
 .. ~2 ra 7(infix - ~3(infix
 + ~2 ra 1 rb
)1 +1)
)(unpackIntoFlat(let i ....))~2,2(stmts
 8(call ~4(dot
 ~4 outp 1 add
)13(dot
 ~5(dot ~3(at ~4 regs 1 i)1 node)1 strVal
))
)
)2,4(call ~2 fn 1 outp)
)
)
)
)
),748(of
(curlyConstr 3 opcContainsSet)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 6(call
 ~5 inSet 9(dot
 ~4(at ~4 regs 1 rb)1 node
)24(dot
 ~4(at ~4 regs 1 rc)1 regToNode
)
)
)
)
)
),751(of
(curlyConstr 3 opcParseFloat)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(var rcAddr . . . 13(call
 ~4 addr 5(at ~4 regs 1 rc)
)),2(if
 3(elif
 12(infix == ~6(dot
 ~6 rcAddr 1 kind
)3 rkRegisterAddr)31(stmts
 7(asgn ~7 rcAddr 8(dot
 ~6 rcAddr 1 regAddr
))
)
)5,1(elif
 14(infix != ~6(dot
 ~4(at ~4 regs 1 rc)1 kind
)3 rkFloat)~3,1(stmts
 9(asgn ~5(at
 ~4 regs 1 rc
)10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkFloat)
))
)
)
)4,6(let coll . . . 15(dot
 ~4(at ~4 regs 1 rb)1 node
)),8(case
 9(dot
 ~4 coll 1 kind
),1(of
(curlyConstr 3 nkTupleConstr)2,1(stmts
 2,1(let data . . . 11(at
 ~4 coll 1 +0
))2,2(let
 left . . . 14(dot ~3(at
 ~4 coll 1 +1
)1 intVal)
)2,3(let right . . . 15(dot
 ~3(at ~4 coll 1 +2)1 intVal
)),4(case
 9(dot
 ~4 data 1 kind
),1(of
(curlyConstr 3 nkStrKinds)2,1(stmts
 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)19(call
 ~17 parseBiggestFloat 24(call
 ~12(dot ~7(dot
 ~4 data 1 strVal
)1 toOpenArray)5(cmd
 ~4 int left
)15(cmd ~4 int right)
)53(dot ~6 rcAddr 1 floatVal)
)
)
)
),3(of
(curlyConstr 3 nkBracket)2,1(stmts
 4(var
 s . . . 18(call
 ~14 newStringOfCap 14(infix + ~7(infix
 - ~6 right 2 left
)2 +1)
)
)4,1(for
 9(infix .. ~4 left 2 right)(unpackIntoFlat
(let i ....)
)~2,1(stmts
 1(cmd
 (dot ~1 s 1 add)10(cmd ~5 char 11(dot
 ~7(at ~4 data 5(cmd
 ~4 int i
))1 intVal
))
)
)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)19(call
 ~17 parseBiggestFloat 1 s 10(dot ~6 rcAddr 1 floatVal)
)
)
)
),8(else
 2,1(stmts
 13(call
 ~13 internalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"opcParseFloat\3A Incorrectly created openarray"
)
)
)
)
)
),16(else
 2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)19(call
 ~17 parseBiggestFloat 14(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)29(dot
 ~6 rcAddr 1 floatVal
)
)
)
)
)
)
)
),779(of
(curlyConstr 3 opcRangeChck)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
)),2(if
 3(elif
 (prefix
 not 4(par
 53(infix
 and ~41(call
 ~11 leValueConv 9(dot ~4(at
 ~4 regs 1 rb
)1 regToNode)29(dot ~4(at
 ~4 regs 1 ra
)1 regToNode)
)~41,1(call
 ~11 leValueConv 9(dot
 ~4(at ~4 regs 1 ra)1 regToNode
)29(dot
 ~4(at ~4 regs 1 rc)1 regToNode
)
)
)
)
)~1,2(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 15,1(infix
 % ~23 errIllegalConvFromXtoY 2(bracketConstr
 ~22,1(prefix
 $ 9(dot ~4(at
 ~4 regs 1 ra
)1 regToNode)
)54,1(infix
 & ~22(infix
 & ~7(infix
 & ~22(infix
 & ~4"\5B" 2(prefix $ 9(dot
 ~4(at ~4 regs 1 rb)1 regToNode
))
)2".."
)2(prefix $ 9(dot
 ~4(at ~4 regs 1 rc)1 regToNode
))
)2"\5D"
)
)
)
)
)
)
)
)
),787(of
(curlyConstr 3 opcIndCall 15 opcIndCallAsgn)2,2(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
))4,2(let
 bb . . . 13(dot ~4(at
 ~4 regs 1 rb
)1 node)
)4,3(let isClosure . . . 20(infix
 == ~6(dot ~2 bb 1 kind)3 nkTupleConstr
))4,4(let
 prc . . . 6(if
 3(elif
 (prefix
 not 4 isClosure
)15(stmts 2(dot ~2 bb 1 sym))
)25(else 6(stmts
 5(dot ~3(at ~2 bb 1 +0)1 sym)
))
)
),5(if
 3(elif
 11(infix
 < ~8(dot ~3 prc 1 offset)2 -1
)~1,2(stmts
 26(call
 ~15(at
 ~10(dot ~1 c 1 callbacks)12(infix
 - ~11(prefix - 4(dot
 ~3 prc 1 offset
))1 +2
)
)~18,1(objConstr
 ~6 VmArgs 3(kv ~2 ra 2 ra)11(kv ~2 rb 2 rb)19(kv
 ~2 rc 2 rc
)30(kv
 ~5 slots 2(cast
 5(ptr 18(at
 ~14 UncheckedArray 1 TFullReg
))40(cmd ~5 addr 4(at
 ~4 regs 1 +0
))
)
)17,1(kv
 ~16 currentException 3(dot ~1 c 1 currentExceptionA)
)16,2(kv ~15 currentLineInfo 9(at
 ~6(dot ~1 c 1 debug)1 pc
))
)
)
)
)5,7(elif
 11(call ~11 importcCond 1 c 4 prc)~3,1(stmts
 (if
 3(elif
 15(infix
 notin ~15 compiletimeFFI 14(dot ~7(dot
 ~1 c 1 config
)1 features)
)~1,1(stmts
 11(call
 ~11 globalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"VM not allowed to do FFI, see `compiletimeFFI`"
)
)
)
),4(when
 5(elif
 hasFFI ~3,1(stmts
 (if
 3(elif
 17(infix < ~4(infix
 - ~10(dot ~3 prc 1 position)2 +1
)2 +0)~1,1(stmts
 11(call
 ~11 globalError 2(dot
 ~1 c 1 config
)18(at ~6(dot ~1 c 1 debug)1 pc)25,1(infix
 & ~34"VM call invalid\3A prc.position\3A " 2(prefix $ 4(dot
 ~3 prc 1 position
))
)
)
)
)
)4,3(let
 prcValue . . . 20(at
 ~8(dot ~1 c 1 globals)13(infix - ~9(dot
 ~3 prc 1 position
)1 +1)
)
),4(if
 3(elif
 14(infix
 == ~6(dot ~8 prcValue 1 kind)3 nkEmpty
)~1,1(stmts
 11(call
 ~11 globalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)38(infix
 & ~14"cannot run " 10(dot ~5(dot
 ~3 prc 1 name
)1 s)
)
)
)
)
)4,6(var
 slots2 . . 8 TNodeSeq 32(call
 ~7(at ~6 newSeq 1 PNode)10(dot ~6(dot
 ~3 tos 1 slots
)1 len)
)
)4,7(for
 6(infix ..< ~1 +0 12(dot
 ~6(dot ~3 tos 1 slots)1 len
))(unpackIntoFlat
(let i ....)
)~2,1(stmts
 10(asgn
 ~4(at ~6 slots2 1 i)11(call
 ~9 regToNode 10(at ~6(dot
 ~3 tos 1 slots
)1 i)
)
)
)
)4,9(let
 newValue . . . 30(call
 ~19 callForeignFunction 2(dot ~1 c 1 config)11 prcValue 24(dot
 ~3 prc 1 typ
)30 slots2 3,1(infix + ~2 rb 1 +1)9,1(infix - ~2 rc 1 +1)20,1(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
),11(if
 3(elif
 14(infix
 != ~6(dot ~8 newValue 1 kind)3 nkEmpty
)~1,1(stmts
 (cmd assert 20(infix
 == ~8(dot ~5 instr 1 opcode)3 opcIndCallAsgn
))10,1(call ~10 putIntoReg 5(at
 ~4 regs 1 ra
)11 newValue)
)
)
)
)
),15(else
 2,1(stmts
 11(call
 ~11 globalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"VM not built with FFI support"
)
)
)
)
)
)5,29(elif
 9(infix
 != ~6(dot ~3 prc 1 kind)3 skTemplate
)~3,1(stmts
 4(let
 newPc . . . 15(call ~7 compile 1 c 4 prc)
),3(if 3(elif
 6(infix < ~6 newPc 2 pc)12(stmts 13(call
 ~13 handleJmpBack
))
))4,5(var
 newFrame . . . 22(objConstr
 ~11 PStackFrame 4(kv
 ~3 prc 2 prc
)20(kv ~9 comesFrom 2 pc)30(kv ~4 next 2 tos)
)
)6,6(call
 ~6 newSeq 9(dot ~8 newFrame 1 slots)27(infix
 + ~7(dot
 ~3 prc 1 offset
)4(call ~3 ord 1 isClosure)
)
),7(if
 3(elif
 (prefix
 not 15(call ~11 isEmptyType 8(dot
 ~4(dot ~3 prc 1 typ)1 returnType
))
)~1,1(stmts
 10(call
 ~10 putIntoReg 15(at
 ~6(dot ~8 newFrame 1 slots)1 +0
)32(call
 ~12 getNullValue 8(dot
 ~4(dot ~3 prc 1 typ)1 returnType
)24(dot ~3 prc 1 info)32(dot ~1 c 1 config)
)
)
)
)
)4,9(for
 6(infix
 .. ~1 +1 4(infix - ~2 rc 1 +1)
)(unpackIntoFlat(let i ....))~2,1(stmts
 18(asgn
 ~4(at ~6(dot
 ~8 newFrame 1 slots
)1 i)6(at ~4 regs 3(infix
 + ~2 rb 1 i
))
)
)
),11(if
 3(elif
 isClosure ~1,1(stmts
 19(asgn
 ~5(at
 ~6(dot ~8 newFrame 1 slots)1 rc
)10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkNode)19(kv ~4 node 15(at
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 +1
))
)
)
)
)
)4,13(asgn ~4 tos 2 newFrame),14 updateRegsAlias 3,16(asgn ~3 pc 7(infix
 - ~5 newPc 1 +1
))
)
),47(else
 2,2(stmts
 4(let
 genSymOwner . . . 14(if
 3(elif
 16(infix
 and ~7(infix != ~6(dot
 ~3 tos 1 next
)3(nil))17(infix
 != ~5(dot ~5(dot
 ~3 tos 1 next
)1 prc)3(nil)
)
)~1,1(stmts 8(dot
 ~5(dot ~3 tos 1 next)1 prc
))
),2(else
 2,1(stmts 1(dot ~1 c 1 module))
)
)
)4,4(var
 macroCall . . . 20(call ~8 newNodeI 1 nkCall 16(at
 ~6(dot ~1 c 1 debug)1 pc
))
)13,5(call ~4(dot ~9 macroCall 1 add)11(call
 ~10 newSymNode 1 prc
))4,6(for
 6(infix .. ~1 +1 4(infix
 - ~2 rc 1 +1
))(unpackIntoFlat(let i ....))~2,1(stmts
 4(let node . . . 17(dot
 ~6(at ~4 regs 3(infix
 + ~2 rb 1 i
))1 regToNode
))10,1(asgn
 ~6(dot
 ~4 node 1 info
)9(at ~6(dot ~1 c 1 debug)1 pc)
),2(if
 3(elif
 16(infix
 notin ~6(dot ~3(at
 ~4(dot ~3 prc 1 typ)1 i
)1 kind)6(curlyConstr
 1 tyTyped 10 tyUntyped
)
)~1,1(stmts
 17(call
 ~13(dot ~4 node 1 annotateType)8(at ~4(dot
 ~3 prc 1 typ
)1 i)14(dot ~1 c 1 config)
)
)
)
)13,5(call
 ~4(dot ~9 macroCall 1 add)1 node
)
)
)4,13(var
 a . . . 16(call
 ~12 evalTemplate 1 macroCall 12 prc 17 genSymOwner 31(dot
 ~1 c 1 config
)41(dot ~1 c 1 cache)50(dot
 ~1 c 1 templInstCounter
)70(dot ~1 c 1 idgen)
)
),14(if
 3(elif
 21(infix
 and ~14(infix
 == ~6(dot ~1 a 1 kind)3 nkStmtList
)10(infix == ~5(dot ~1 a 1 len)3 +1)
)37(stmts
 2(asgn ~2 a 3(at ~1 a 1 +0))
)
)
)1,15(dot ~1 a 1 recSetFlagIsRef)10,16(call
 ~10 ensureKind 1 rkNode
)14,17(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 a
)
)
)
)
)
),861(of
(curlyConstr 3 opcTJmp)2,2(stmts
 4(let
 rbx . . . 31(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
)
),1(if
 3(elif
 16(infix != ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)3 +0)~1,1(stmts (cmd
 inc 4 pc 8 rbx
))
)
)
)
),866(of
(curlyConstr 3 opcFJmp)2,2(stmts
 4(let
 rbx . . . 31(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
)
),1(if
 3(elif
 16(infix == ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)3 +0)~1,1(stmts (cmd
 inc 4 pc 8 rbx
))
)
)
)
),871(of
(curlyConstr 3 opcJmp)2,2(stmts
 4(let
 rbx . . . 31(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
)
),1(cmd inc 4 pc 8 rbx)
)
),875(of
(curlyConstr 3 opcJmpBack)2,1(stmts
 4(let
 rbx . . . 31(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
)
),1(cmd inc 4 pc 8 rbx)13,2(call
 ~13 handleJmpBack
)
)
),879(of
(curlyConstr 3 opcBranch)2,2(stmts
 4(let
 branch . . . 20(at ~10(dot
 ~1 c 1 constants
)12(infix
 - ~6(dot ~5 instr 1 regBx)1 wordExcess
))
)4,1(var cond . . . 7 false)4,2(for
 6(infix
 ..< ~1 +0 14(infix - ~5(dot
 ~6 branch 1 len
)2 +1)
)(unpackIntoFlat(let j ....))~2,1(stmts
 (if
 3(elif
 7(call ~7 overlap 9(dot ~4(at
 ~4 regs 1 ra
)1 regToNode)27(at
 ~6 branch 1 j
))~1,1(stmts 5(asgn
 ~5 cond 2 true
),1(brk .))
)
)
)
),6(cmd
 assert 27(infix
 == ~8(dot
 ~6(at ~5(dot ~1 c 1 code)3(infix
 + ~2 pc 1 +1
))1 opcode
)3 opcFJmp
)
),7(cmd inc 4 pc),10(if
 3(elif
 (prefix not 4 cond)~1,1(stmts
 4(let
 instr2 . . . 15(at ~5(dot
 ~1 c 1 code
)1 pc)
)4,1(let
 rbx . . . 32(infix - ~13(infix
 - ~7(dot ~6 instr2 1 regBx)2 wordExcess
)2 +1)
),2(cmd inc 4 pc 8 rbx)
)
)
)
)
),895(of
(curlyConstr 3 opcTry)2,1(stmts
 4(let
 rbx . . . 18(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)17,1(call ~14(dot ~3 tos 1 pushSafePoint)4(infix
 + ~3 pc 2 rbx
)),2(cmd
 assert 29(infix
 in ~8(dot ~8(at
 ~5(dot
 ~1 c 1 code
)3(infix + ~2 pc 1 rbx)
)1 opcode)3(curlyConstr
 1 opcExcept 12 opcFinally
)
)
)
)
),899(of
(curlyConstr 3 opcExcept)2,3(stmts (cmd
 raiseAssert 12"unreachable"
))
),903(of
(curlyConstr 3 opcFinally)2,4(stmts
 8(call ~8 doAssert 9(infix
 < ~8 savedPC 2 +0
))16,1(call ~13(dot
 ~3 tos 1 popSafePoint
))
)
),909(of
(curlyConstr 3 opcFinallyEnd)2,3(stmts
 (if
 3(elif
 8(infix
 >= ~8 savedPC 3 +0
)~1,1(stmts
 3(asgn
 ~3 pc 10(infix - ~8 savedPC 2 +1)
)8,1(asgn ~8 savedPC 2 -1),2(if
 3(elif
 4(infix
 != ~4 tos 3 savedFrame
)~1,1(stmts
 4(asgn ~4 tos 2 savedFrame),1 updateRegsAlias
)
)
)
)
)
)
)
),918(of
(curlyConstr 3 opcRaise)2,1(stmts
 4(let
 raised . . . ~2,2(if
 3(elif
 14(infix
 == ~6(dot ~4(at
 ~4 regs 1 ra
)1 kind)3 rkNone
)~1,1(stmts
 1(dot ~1 c 1 currentExceptionA)
)
),2(else
 2,1(stmts 8(dot
 ~4(at ~4 regs 1 ra)1 node
))
)
)
)20,6(asgn
 ~19(dot ~1 c 1 currentExceptionA)2 raised
)4,8(var
 exceptionNameNode . . . 30(call
 ~10 newStrNode 1 nkStrLit 43(dot
 ~5(dot ~4(dot
 ~4(dot ~18(dot
 ~1 c 1 currentExceptionA
)1 typ)1 sym
)1 name)1 s
)
)
),9(if
 3(elif
 28(infix
 == ~6(dot ~3(at
 ~18(dot ~1 c 1 currentExceptionA)1 +2
)1 kind)3 nkExprColonExpr
)~1,1(stmts
 22(asgn
 ~5(dot ~17 exceptionNameNode 1 typ)27(dot ~3(at
 ~3(at ~18(dot
 ~1 c 1 currentExceptionA
)1 +2)1 +1
)1 typ)
)26,1(asgn
 ~4(at ~3(at
 ~18(dot ~1 c 1 currentExceptionA)1 +2
)1 +1)2 exceptionNameNode
)
)
),3(else
 2,1(stmts
 22(asgn
 ~5(dot ~17 exceptionNameNode 1 typ)24(dot
 ~3(at ~18(dot
 ~1 c 1 currentExceptionA
)1 +2)1 typ
)
)23,1(asgn
 ~4(at
 ~18(dot ~1 c 1 currentExceptionA)1 +2
)2 exceptionNameNode
)
)
)
)17,15(asgn
 ~16(dot ~1 c 1 exceptionInstr)2 pc
)4,17(var frame . . . 8 tos)4,18(var jumpTo . . . 29(call
 ~20 findExceptionHandler 1 c 4 frame 11 raised
)),19(while
 43(infix
 and ~26(infix == ~5(dot
 ~6 jumpTo 1 why
)3 ExceptionGotoUnhandled)4(prefix
 not 14(dot ~5(dot
 ~5 frame 1 next
)1 isNil)
)
)2,1(stmts
 6(asgn
 ~6 frame 7(dot ~5 frame 1 next)
)7,1(asgn ~7 jumpTo 22(call
 ~20 findExceptionHandler 1 c 4 frame 11 raised
))
)
),23(case
 11(dot ~6 jumpTo 1 why),1(of
(curlyConstr
 3 ExceptionGotoHandler
)2,2(stmts
 8(asgn ~8 savedPC 2 -1)3,1(asgn
 ~3 pc 15(infix - ~7(dot
 ~6 jumpTo 1 where
)2 +1)
),2(if
 3(elif
 4(infix != ~4 tos 3 frame)~1,1(stmts 4(asgn
 ~4 tos 2 frame
),1 updateRegsAlias)
)
)
)
),8(of
(curlyConstr 3 ExceptionGotoFinally)2,3(stmts
 8(asgn
 ~8 savedPC 2 pc
)11,1(asgn ~11 savedFrame 2 tos)3,2(asgn
 ~3 pc 15(infix - ~7(dot
 ~6 jumpTo 1 where
)2 +1)
),3(if
 3(elif
 4(infix != ~4 tos 3 frame)~1,1(stmts 4(asgn
 ~4 tos 2 frame
),1 updateRegsAlias)
)
)
)
),17(of
(curlyConstr 3 ExceptionGotoUnhandled)2,2(stmts 7(call
 ~7 bailOut 1 c 4 tos
))
)
)
)
),962(of
(curlyConstr 3 opcNew)2,1(stmts
 10(call
 ~10 ensureKind 1 rkNode
)4,1(let
 typ . . . 13(at
 ~6(dot ~1 c 1 types)13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)
)14,2(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)14(call
 ~12 getNullValue 1 typ 13(at ~6(dot
 ~1 c 1 debug
)1 pc)20(dot ~1 c 1 config)
)
)19,3(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
),967(of
(curlyConstr 3 opcNewSeq)2,1(stmts
 4(let
 typ . . . 13(at ~6(dot
 ~1 c 1 types
)13(infix
 - ~7(dot ~5 instr 1 regBx)2 wordExcess
))
),1(cmd inc 4 pc)10,2(call
 ~10 ensureKind 1 rkNode
)4,3(let instr2 . . . 15(at
 ~5(dot ~1 c 1 code)1 pc
))4,4(let
 count . . . 32(dot ~7(dot
 ~13(at ~4 regs 7(dot
 ~6 instr2 1 regA
))1 intVal
)1 int)
)14,5(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)10(call
 ~8 newNodeI 1 nkBracket 19(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)18,6(asgn
 ~5(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 typ)2 typ
)6,7(call
 ~6 newSeq 14(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 sons)21 count
)4,8(for
 6(infix ..< ~1 +0 3 count)(unpackIntoFlat
(let i ....)
)~2,1(stmts
 17(asgn
 ~4(at ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 i)14(call
 ~12 getNullValue 4(dot
 ~3 typ 1 elementType
)25(at ~6(dot ~1 c 1 debug)1 pc)32(dot
 ~1 c 1 config
)
)
)
)
)
)
),978(of
(curlyConstr 3 opcNewStr)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)10(call
 ~8 newNodeI 1 nkStrLit 18(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)21,2(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)11(call ~9 newString 16(dot
 ~7(dot ~4(at
 ~4 regs 1 rb
)1 intVal)1 int
))
)
)
),982(of
(curlyConstr 3 opcLdImmInt)2,2(stmts
 8(call
 ~8 decodeBx 1 rkInt
)16,1(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 rbx)
)
),986(of
(curlyConstr 3 opcLdNull)2,1(stmts
 10(call
 ~10 ensureKind 1 rkNode
)4,1(let
 typ . . . 13(at
 ~6(dot ~1 c 1 types)13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)
)14,2(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)14(call
 ~12 getNullValue 1 typ 13(at ~6(dot
 ~1 c 1 debug
)1 pc)20(dot ~1 c 1 config)
)
)
)
),996(of
(curlyConstr 3 opcLdNullReg)2,1(stmts
 4(let
 typ . . . 13(at ~6(dot
 ~1 c 1 types
)13(infix
 - ~7(dot ~5 instr 1 regBx)2 wordExcess
))
),1(if
 3(elif
 56(infix
 in ~6(dot
 ~37(call
 ~10(dot ~3 typ 1 skipTypes)23(infix
 - ~10(infix + ~12 abstractInst 1(curlyConstr
 1 tyRange
))1(curlyConstr
 1 tyTypeDesc
)
)
)1 kind
)3(curlyConstr
 ~51,1(infix .. ~7 tyFloat 2 tyFloat128)
)
)~1,2(stmts
 10(call ~10 ensureKind 1 rkFloat)18,1(asgn
 ~10(dot ~4(at
 ~4 regs 1 ra
)1 floatVal)2 +0.0
)
)
),4(else
 2,1(stmts
 10(call ~10 ensureKind 1 rkInt)16,1(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)2 +0
)
)
)
)
)
),1005(of
(curlyConstr 3 opcLdConst)2,1(stmts
 4(let
 rb . . . 17(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)4,1(let cnst . . . 18(at
 ~10(dot ~1 c 1 constants)1 rb
)),2(if
 3(elif
 12(call ~12 fitsRegister 5(dot
 ~4 cnst 1 typ
))~1,1(stmts
 5(call ~5 reset 5(at
 ~4 regs 1 ra
))10,1(call ~10 putIntoReg 5(at
 ~4 regs 1 ra
)11 cnst)
)
),3(else
 2,1(stmts
 10(call ~10 ensureKind 1 rkNode)14,1(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 cnst
)
)
)
)
)
),1014(of
(curlyConstr 3 opcAsgnConst)2,1(stmts
 4(let
 rb . . . 17(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)
)4,1(let cnst . . . 18(at
 ~10(dot ~1 c 1 constants)1 rb
)),2(if
 3(elif
 12(call ~12 fitsRegister 5(dot
 ~4 cnst 1 typ
))~1,1(stmts
 10(call ~10 putIntoReg 5(at
 ~4 regs 1 ra
)11 cnst)
)
),2(else
 2,1(stmts
 10(call ~10 ensureKind 1 rkNode)14,1(asgn ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)6(dot
 ~4 cnst 1 copyTree
))
)
)
)
)
),1022(of
(curlyConstr 3 opcLdGlobal)2,1(stmts
 4(let rb . . . 30(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
))10,1(call
 ~10 ensureKind 1 rkNode
)14,2(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)11(at ~8(dot
 ~1 c 1 globals
)1 rb)
)
)
),1026(of
(curlyConstr 3 opcLdGlobalDerefFFI)2,1(stmts
 4(let rb . . . 30(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
))4,1(let
 node . . . 16(at ~8(dot
 ~1 c 1 globals
)1 rb)
)4,2(let
 typ . . . 10(dot ~4 node 1 typ)
),3(cmd
 doAssert 19(infix
 == ~6(dot ~4 node 1 kind)3 nkIntLit
)32(prefix
 $ 1(par 5(dot ~4 node 1 kind))
)
),4(if
 3(elif
 9(infix
 == ~6(dot ~3 typ 1 kind)3 tyPtr
)~1,1(stmts
 10(call ~10 ensureKind 1 rkNode)4,2(let
 node2 . . . 17(call
 ~9 newNodeIT 1 nkIntLit 18(at ~6(dot
 ~1 c 1 debug
)1 pc)24 typ
)
)13,3(asgn
 ~8(dot ~5 node2 1 intVal)28(at
 ~26(cast 5(ptr 4 int)18(dot
 ~4 node 1 intVal
))
)
)11,4(cmd (dot
 ~6(dot ~5 node2 1 flags)1 incl
)6 nfIsPtr)14,5(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 node2
)
)
)5,7(elif
 (prefix
 not 17(call
 ~13 derefPtrToReg 5(dot ~4 node 1 intVal)14 typ 23(at
 ~4 regs 1 ra
)38(vv ~9 isAssign 2 false)
)
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 45(infix
 & ~32"opcLdDeref unsupported type\3A " 2(prefix
 $ 1(tupleConstr
 13(call
 ~12 typeToString 1 typ
)35(dot
 ~12(dot ~3 typ 1 elementType)1 kind
)
)
)
)
)
)
)
)
)
),1040(of
(curlyConstr 3 opcLdGlobalAddrDerefFFI)2,1(stmts
 4(let rb . . . 30(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
))4,1(let
 node . . . 16(at ~8(dot
 ~1 c 1 globals
)1 rb)
)4,2(let
 typ . . . 10(dot ~4 node 1 typ)
)4,3(var node2 . . . 17(call
 ~9 newNodeIT 1 nkIntLit 15(dot ~4 node 1 info)22 typ
))13,4(asgn
 ~8(dot
 ~5 node2 1 intVal
)6(dot ~4 node 1 intVal)
)11,5(cmd (dot
 ~6(dot ~5 node2 1 flags)1 incl
)6 nfIsPtr)10,6(call
 ~10 ensureKind 1 rkNode
)14,7(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 node2
)
)
),1049(of
(curlyConstr 3 opcLdGlobalAddr)2,1(stmts
 4(let rb . . . 30(infix
 - ~13(infix - ~7(dot
 ~5 instr 1 regBx
)2 wordExcess)2 +1
))10,1(call
 ~10 ensureKind 1 rkNodeAddr
)18,2(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 nodeAddr
)6(call ~4 addr 10(at
 ~8(dot ~1 c 1 globals)1 rb
))
)
)
),1053(of
(curlyConstr 3 opcRepr)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(cmd createStr 14(at ~4 regs 1 ra))21,2(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)12(call
 ~10 renderTree 9(dot
 ~4(at ~4 regs 1 rb)1 regToNode
)21(curlyConstr
 1 renderNoComments 19 renderDocComments 38 renderNonExportedFields
)
)
)
)
),1057(of
(curlyConstr 3 opcQuit)2,1(stmts
 (if
 3(elif
 7(infix
 in ~6(dot
 ~1 c 1 mode
)3(curlyConstr
 1 emRepl 9 emStaticExpr 23 emStaticStmt
)
)~1,1(stmts
 7(call
 ~7 message 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24 hintQuitCalled
)7,1(call
 ~7 msgQuit 5(call
 ~4 int8 6(call
 ~5 toInt 12(call
 ~11 getOrdValue 9(dot ~4(at
 ~4 regs 1 ra
)1 regToNode)29(vv ~8 onError 10(call
 ~8 toInt128 1 +1
))
)
)
)
)
)
),3(else 2,1(stmts
 (ret 15(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkNone)
))
))
)
)
),1063(of
(curlyConstr 3 opcInvalidField)2,1(stmts
 4(let msg . . . 19(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
))4,1(let disc . . . 23(dot
 ~12(at ~4 regs 6(dot
 ~5 instr 1 regB
))1 regToNode
))4,2(let
 msg2 . . . 24(call ~17 formatFieldDefect 1 msg 6(prefix
 $ 1 disc
))
)10,3(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 msg2
)
)
),1068(of
(curlyConstr 3 opcSetLenStr)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)27,2(call
 ~7(dot
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)1 setLen
)16(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
)
)
),1072(of
(curlyConstr 3 opcOf)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let
 typ . . . 13(at ~6(dot ~1 c 1 types)16(dot
 ~7(dot ~4(at
 ~4 regs 1 rc
)1 intVal)1 int
))
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 41(infix
 <= ~25(call
 ~15 inheritanceDiff 14(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)20 typ
)3 +0
)
)
)
)
),1076(of
(curlyConstr 3 opcIs)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,1(let
 t1 . . . 32(call
 ~10(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)1 skipTypes
)1(curlyConstr 1 tyTypeDesc)
)
)4,2(let
 t2 . . . 12(at ~6(dot ~1 c 1 types)16(dot
 ~7(dot ~4(at
 ~4 regs 1 rc
)1 intVal)1 int
))
)4,4(let
 match . . . 8(if
 3(elif
 8(infix
 == ~6(dot ~2 t2 1 kind)3 tyUserTypeClass
)28(stmts true)
),1(else 6(stmts
 8(call ~8 sameType 1 t1 5 t2)
))
)
)16,6(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call ~3 ord 1 match)
)
)
),1084(of
(curlyConstr 3 opcSetLenSeq)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let
 newLen . . . 24(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
),2(if
 3(elif
 13(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 isNil)21(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13 errNilAccess
))
),1(else
 6(stmts
 11(call
 ~10(dot ~1 c 1 setLenSeq)9(dot ~4(at
 ~4 regs 1 ra
)1 node)16 newLen 31(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)
)
)
)
),1089(of
(curlyConstr 3 opcNarrowS)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)4,1(let
 min . . . 6(prefix
 - 1(par 14(infix
 shl ~12(dot ~1 +1 1 BiggestInt)4(par 3(infix
 - ~2 rb 1 +1
))
))
)
)4,2(let
 max . . . 31(infix
 - ~25(par 14(infix
 shl ~12(dot ~1 +1 1 BiggestInt)4(par 3(infix
 - ~2 rb 1 +1
))
))1 +1
)
),3(if
 3(elif
 22(infix
 or ~6(infix < ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 min)19(infix
 > ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)2 max
)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"unhandled exception\3A value out of range"
)
)
)
)
)
),1095(of
(curlyConstr 3 opcNarrowU)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)18(infix
 and ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)4(par
 15(infix - ~14(par
 7(infix shl ~6 +1i64 4 rb)
)1 +1)
)
)
)
)
),1098(of
(curlyConstr 3 opcSignExtend)2,2(stmts
 7(call
 ~7 decodeB 1 rkInt
)4,1(let
 imm . . . 9(infix - ~3 +64 2 rb)
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)6(call
 ~4 ashr 17(infix shl ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)4 imm)26 imm
)
)
)
),1103(of
(curlyConstr 3 opcIsNil)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)4,1(let node . . . 15(dot
 ~4(at ~4 regs 1 rb)1 node
))16,2(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)5(call
 ~3 ord 34,3(infix
 or ~53(par
 23(infix
 and ~12(infix == ~6(dot
 ~4 node 1 kind
)3 nkNilLit)12(infix notin ~8 nfIsRef 10(dot
 ~4 node 1 flags
))
)
)~53,1(par
 27,2(infix
 and 27,-1(infix
 and ~21(infix
 and 15,-1(infix
 and ~28(infix
 and ~19(prefix
 not 12(dot ~4(dot
 ~4 node 1 typ
)1 isNil)
)18(infix == ~6(dot
 ~4(dot ~4 node 1 typ)1 kind
)3 tyProc)
)~28,1(infix == ~10(dot
 ~4(dot ~4 node 1 typ)1 callConv
)3 ccClosure)
)17(infix
 > ~9(dot ~4 node 1 safeLen)2 +0
)
)~39,1(infix
 == ~6(dot ~3(at ~4 node 1 +0)1 kind)3 nkNilLit
)
)17(infix
 == ~6(dot ~3(at ~4 node 1 +1)1 kind)3 nkNilLit
)
)
)
)
)
)
)
),1113(of
(curlyConstr 3 opcNBindSym)2,5(stmts
 8(call
 ~8 decodeBx 1 rkNode
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)10(call
 ~8 copyTree 12(at ~10(dot
 ~1 c 1 constants
)1 rbx)
)
)19,2(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
),1121(of
(curlyConstr 3 opcNDynBindSym)2,2(stmts
 2,1(let rb . . . 10(dot
 ~5 instr 1 regB
))2,2(let rc . . . 10(dot
 ~5 instr 1 regC
))2,3(let
 idx . . . 9(call
 ~3 int 14(dot ~9(at
 ~4 regs 6(infix - ~3(infix
 + ~2 rb 1 rc
)1 +1)
)1 intVal)
)
)2,4(let callback . . . 22(at
 ~10(dot ~1 c 1 callbacks)1 idx
))2,5(let
 args . . . 13(objConstr
 ~6 VmArgs 3(kv
 ~2 ra 2 ra
)11(kv ~2 rb 2 rb)19(kv ~2 rc 2 rc)30(kv
 ~5 slots 2(cast
 5(ptr 18(at
 ~14 UncheckedArray 1 TFullReg
))40(cmd ~5 addr 4(at
 ~4 regs 1 +0
))
)
)11,1(kv
 ~16 currentException 3(dot ~1 c 1 currentExceptionA)
)10,2(kv ~15 currentLineInfo 9(at
 ~6(dot ~1 c 1 debug)1 pc
))
)
)8,8(call ~8 callback 1 args)19,9(cmd
 (dot ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 flags
)1 incl)6 nfIsRef
)
)
),1133(of
(curlyConstr 3 opcNChild)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)4,2(let src . . . 14(dot
 ~4(at ~4 regs 1 rb)1 node
)),3(if
 3(elif
 9(infix
 in ~6(dot
 ~3 src 1 kind
)3(curlyConstr
 8(infix .. ~7 nkEmpty 2 nkNilLit)
)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 48(infix
 & ~35"cannot get child of node kind\3A n" 2(prefix $ 4(dot
 ~3 src 1 kind
))
)
)
)
)5,2(elif
 4(infix
 >=% ~4 idx 7(dot ~3 src 1 len)
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 13(infix - ~4(dot
 ~3 src 1 len
)1 +1)
)
)
)
),4(else
 2,1(stmts 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)5(at ~3 src 1 idx)
))
)
)
)
),1143(of
(curlyConstr 3 opcNSetChild)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 idx . . . 21(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
)4,2(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),3(if
 3(elif
 20(infix
 and ~14(infix in ~6 nfSem 7(dot
 ~4 dest 1 flags
))35(infix
 notin ~31 allowSemcheckedAstModification 14(dot ~7(dot
 ~1 c 1 config
)1 legacyFeatures)
)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"typechecked nodes may not be modified"
)
)
)5,2(elif
 10(infix
 in ~6(dot ~4 dest 1 kind)3(curlyConstr 8(infix
 .. ~7 nkEmpty 2 nkNilLit
))
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 48(infix
 & ~35"cannot set child of node kind\3A n" 2(prefix $ 5(dot
 ~4 dest 1 kind
))
)
)
)
)5,4(elif
 4(infix
 >=% ~4 idx 8(dot ~4 dest 1 len)
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 14(infix - ~4(dot
 ~4 dest 1 len
)1 +1)
)
)
)
),6(else
 2,1(stmts 10(asgn
 ~6(at ~4 dest 1 idx)10(dot ~4(at
 ~4 regs 1 rc
)1 node)
))
)
)
)
),1155(of
(curlyConstr 3 opcNAdd)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(var u . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 17(infix
 and ~11(infix in ~6 nfSem 4(dot
 ~1 u 1 flags
))35(infix
 notin ~31 allowSemcheckedAstModification 14(dot ~7(dot
 ~1 c 1 config
)1 legacyFeatures)
)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"typechecked nodes may not be modified"
)
)
)5,2(elif
 7(infix
 in ~6(dot ~1 u 1 kind)3(curlyConstr 8(infix
 .. ~7 nkEmpty 2 nkNilLit
))
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 42(infix
 & ~29"cannot add to node kind\3A n" 2(prefix $ 2(dot
 ~1 u 1 kind
))
)
)
)
),4(else 2,1(stmts
 5(call ~4(dot ~1 u 1 add)9(dot
 ~4(at ~4 regs 1 rc)1 node
))
))
)14,8(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 u
)
)
),1165(of
(curlyConstr 3 opcNAddMultiple)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let x . . . 12(dot
 ~4(at ~4 regs 1 rc)1 node
))4,2(var
 u . . . 12(dot ~4(at
 ~4 regs 1 rb
)1 node)
),3(if
 3(elif
 17(infix
 and ~11(infix
 in ~6 nfSem 4(dot ~1 u 1 flags)
)35(infix
 notin ~31 allowSemcheckedAstModification 14(dot
 ~7(dot ~1 c 1 config)1 legacyFeatures
)
)
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"typechecked nodes may not be modified"
)
)
)5,2(elif
 7(infix
 in ~6(dot ~1 u 1 kind)3(curlyConstr 8(infix
 .. ~7 nkEmpty 2 nkNilLit
))
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 42(infix
 & ~29"cannot add to node kind\3A n" 2(prefix $ 2(dot
 ~1 u 1 kind
))
)
)
)
),4(else
 2,1(stmts
 4(for
 6(infix
 ..< ~1 +0 4(dot ~1 x 1 len)
)(unpackIntoFlat(let i ....))16(stmts
 5(call ~4(dot ~1 u 1 add)2(at
 ~1 x 1 i
))
)
)
)
)
)14,9(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 u
)
)
),1176(of
(curlyConstr 3 opcNKind)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)16,1(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 14(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 kind)
)
)21,2(asgn
 ~20(dot ~1 c 1 comesFromHeuristic)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 info
)
)
)
),1180(of
(curlyConstr 3 opcNSymKind)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkSym)~1,1(stmts
 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)5(call
 ~3 ord 6(dot ~4(dot
 ~1 a 1 sym
)1 kind)
)
)
)
),2(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a symbol"
))
)
)21,6(asgn
 ~20(dot ~1 c 1 comesFromHeuristic)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 info
)
)
)
),1188(of
(curlyConstr 3 opcNIntVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix
 in ~6(dot
 ~1 a 1 kind
)3(curlyConstr
 10(infix .. ~9 nkCharLit 2 nkUInt64Lit)
)
)~1,1(stmts 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)3(dot ~1 a 1 intVal)
))
)5,2(elif
 16(infix
 and ~9(infix
 == ~6(dot ~1 a 1 kind)3 nkSym
)15(infix
 == ~6(dot ~4(dot ~1 a 1 sym)1 kind)3 skEnumField
)
)~3,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)7(dot ~4(dot ~1 a 1 sym)1 position)
)
)
),4(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"intVal"
))
)
)
)
)
),1197(of
(curlyConstr 3 opcNFloatVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkFloat
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(case
 6(dot
 ~1 a 1 kind
),1(of
(curlyConstr
 13(infix .. ~10 nkFloatLit 2 nkFloat64Lit)
)29(stmts 18(asgn
 ~10(dot
 ~4(at ~4 regs 1 ra)1 floatVal
)3(dot ~1 a 1 floatVal)
))
),2(else
 6(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"floatVal"
)
)
)
)
)
)
),1203(of
(curlyConstr 3 opcNSymbol)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkSym)~1,1(stmts 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)10(call ~8 copyNode 1 a)
))
),2(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"symbol"
))
)
)
)
)
),1210(of
(curlyConstr 3 opcNIdent)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(let a . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(if
 3(elif
 7(infix == ~6(dot
 ~1 a 1 kind
)3 nkIdent)~1,1(stmts 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)10(call ~8 copyNode 1 a)
))
),2(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"ident"
))
)
)
)
)
),1217(of
(curlyConstr 3 opcNodeId)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
),1(when
 5(elif
 7(call ~7 defined 1 useNodeIds)~3,1(stmts
 16(asgn
 ~8(dot ~4(at
 ~4 regs 1 ra
)1 intVal)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 id
)
)
)
),2(else 2,1(stmts
 16(asgn ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)2 -1)
))
)
)
),1223(of
(curlyConstr 3 opcNGetType)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
))4,1(let rc . . . 10(dot
 ~5 instr 1 regC
)),2(case
 5 rc ,1(of
(curlyConstr 3 +0)2,2(stmts
 10(call
 ~10 ensureKind 1 rkNode
),1(if
 3(elif
 24(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)22(infix != ~5(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)3(nil))
)~1,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)16(call
 ~14 opMapTypeToAst 2(dot ~1 c 1 cache)23(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)36(at ~6(dot ~1 c 1 debug)1 pc)43(dot
 ~1 c 1 idgen
)
)
)
)
)5,2(elif
 56(infix
 and ~32(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)
)26(infix
 != ~5(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 sym)1 typ
)3(nil)
)
)~3,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)16(call
 ~14 opMapTypeToAst 2(dot ~1 c 1 cache)27(dot ~4(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 sym
)1 typ)40(at ~6(dot
 ~1 c 1 debug
)1 pc)47(dot ~1 c 1 idgen)
)
)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node has no type"
))
)
)
)
),10(of
(curlyConstr 3 +1)2,2(stmts
 10(call
 ~10 ensureKind 1 rkInt
),1(if
 3(elif
 24(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)22(infix != ~5(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)3(nil))
)~1,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call ~3 ord 18(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)1 kind
))
)
)
)5,2(elif
 56(infix
 and ~32(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)
)26(infix
 != ~5(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 sym)1 typ
)3(nil)
)
)~3,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)5(call
 ~3 ord 22(dot
 ~4(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 sym)1 typ
)1 kind
)
)
)
)
)
)
)
),19(of
(curlyConstr 3 +2)2,2(stmts
 10(call
 ~10 ensureKind 1 rkNode
),1(if
 3(elif
 24(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)22(infix != ~5(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)3(nil))
)~1,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)20(call
 ~18 opMapTypeInstToAst 2(dot ~1 c 1 cache)23(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)36(at ~6(dot ~1 c 1 debug)1 pc)43(dot
 ~1 c 1 idgen
)
)
)
)
)5,2(elif
 56(infix
 and ~32(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)
)26(infix
 != ~5(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 sym)1 typ
)3(nil)
)
)~3,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)20(call
 ~18 opMapTypeInstToAst 2(dot ~1 c 1 cache)27(dot ~4(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 sym
)1 typ)40(at ~6(dot
 ~1 c 1 debug
)1 pc)47(dot ~1 c 1 idgen)
)
)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node has no type"
))
)
)
)
),28(else
 2,2(stmts
 10(call ~10 ensureKind 1 rkNode),1(if
 3(elif
 24(infix
 and ~10(infix
 == ~6(dot ~4(at
 ~4 regs 1 rb
)1 kind)3 rkNode
)22(infix
 != ~5(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)3(nil)
)
)~1,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)20(call
 ~18 opMapTypeImplToAst 2(dot ~1 c 1 cache)23(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 typ
)36(at ~6(dot ~1 c 1 debug)1 pc)43(dot
 ~1 c 1 idgen
)
)
)
)
)5,2(elif
 56(infix
 and ~32(infix
 and ~10(infix == ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3 rkNode)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)
)26(infix
 != ~5(dot
 ~4(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 sym)1 typ
)3(nil)
)
)~3,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)20(call
 ~18 opMapTypeImplToAst 2(dot ~1 c 1 cache)27(dot ~4(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 sym
)1 typ)40(at ~6(dot
 ~1 c 1 debug
)1 pc)47(dot ~1 c 1 idgen)
)
)
)
),4(else
 2,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node has no type"
))
)
)
)
)
)
)
),1263(of
(curlyConstr 3 opcNGetSize)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkInt
)4,1(let n . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(case
 5 imm ,1(of
(curlyConstr
 3 +0
)2,1(stmts
 (if
 3(elif
 6(infix
 == ~5(dot ~1 n 1 typ)3(nil)
)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node has no type"
))
),2(else
 2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)9(call
 ~7 getSize 2(dot ~1 c 1 config)12(dot ~1 n 1 typ)
)
)
)
)
)
)
),6(of
(curlyConstr 3 +1)2,1(stmts
 (if
 3(elif
 6(infix
 == ~5(dot ~1 n 1 typ)3(nil)
)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node has no type"
))
),2(else
 2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)10(call
 ~8 getAlign 2(dot ~1 c 1 config)12(dot ~1 n 1 typ)
)
)
)
)
)
)
),11(else
 2,1(stmts
 (if
 3(elif
 7(infix
 != ~6(dot ~1 n 1 kind)3 nkSym
)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a symbol"
))
)5,2(elif
 11(infix != ~6(dot
 ~4(dot ~1 n 1 sym)1 kind
)3 skField)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"symbol is not a field \28nskField\29"
)
)
),4(else
 2,1(stmts
 16(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)7(dot ~4(dot ~1 n 1 sym)1 offset)
)
)
)
)
)
)
)
)
),1284(of
(curlyConstr 3 opcNStrVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(cmd createStr 14(at ~4 regs 1 ra))4,2(let
 a . . . 12(dot ~4(at
 ~4 regs 1 rb
)1 node)
),3(case
 6(dot ~1 a 1 kind),1(of
(curlyConstr 11(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))2,1(stmts
 21(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)3(dot ~1 a 1 strVal)
)
)
),3(of
(curlyConstr 3 nkCommentStmt)2,1(stmts
 21(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)3(dot ~1 a 1 comment)
)
)
),5(of
(curlyConstr 3 nkIdent)2,1(stmts
 21(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)9(dot ~6(dot ~1 a 1 ident)1 s)
)
)
),7(of
(curlyConstr 3 nkSym)2,1(stmts
 21(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)12(dot
 ~5(dot ~4(dot
 ~1 a 1 sym
)1 name)1 s
)
)
)
),9(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"strVal"
))
)
)
)
)
),1299(of
(curlyConstr 3 opcNSigHash)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(cmd createStr 14(at ~4 regs 1 ra)),2(if
 3(elif
 19(infix != ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"node is not a symbol"
))
),2(else
 2,1(stmts
 21(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)2(prefix
 $ 8(call
 ~7 sigHash 14(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 sym
)21(dot ~1 c 1 config)
)
)
)
)
)
)
)
),1306(of
(curlyConstr 3 opcSlurp)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(cmd createStr 14(at ~4 regs 1 ra))21,2(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)9(call
 ~7 opSlurp 14(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)30(at ~6(dot
 ~1 c 1 debug
)1 pc)2,1(dot ~1 c 1 module)12,1(dot
 ~1 c 1 config
)
)
)
)
),1311(of
(curlyConstr 3 opcGorge)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
),1(cmd inc 4 pc)4,2(let
 rd . . . 15(dot ~4(at
 ~5(dot ~1 c 1 code)1 pc
)1 regA)
),3(cmd createStr 14(at ~4 regs 1 ra)),4(if
 3(elif
 20(infix
 or ~13(call
 ~7 defined 1 nimsuggest
)16(infix == ~5(dot
 ~7(dot ~1 c 1 config)1 cmd
)3 cmdCheck)
)~1,1(stmts
 (discard
 8"don\27t run staticExec for \27nim suggest\27"
)21,1(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)2""
)
)
),3(else
 2,1(stmts
 (when
 5(elif
 7(call ~7 defined 1 nimcore)~3,1(stmts
 21(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)31,2(at
 ~22,-2(call
 ~7 opGorge 14(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 strVal)13,1(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)35,1(dot
 ~5(dot ~4(at ~4 regs 1 rd)1 node)1 strVal
)7,2(at ~6(dot ~1 c 1 debug)1 pc)14,2(dot
 ~1 c 1 config
)
)1 +0
)
)
)
),4(else
 2,1(stmts
 21(asgn
 ~8(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 strVal)2""
)11,1(call
 ~11 globalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"VM is not built with \27gorge\27 support"
)
)
)
)
)
)
)
)
),1327(of
(curlyConstr
 3 opcNError 14 opcNWarning 27 opcNHint
)2,1(stmts
 7(call ~7 decodeB 1 rkNode)4,1(let
 a . . . 12(dot ~4(at
 ~4 regs 1 ra
)1 node)
)4,2(let b . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
))4,3(let
 info . . . 7(if
 3(elif
 7(infix == ~6(dot
 ~1 b 1 kind
)3 nkNilLit)20(stmts 7(at ~6(dot
 ~1 c 1 debug
)1 pc))
)35(else
 6(stmts 1(dot ~1 b 1 info))
)
)
),4(if
 3(elif
 13(infix
 == ~8(dot ~5 instr 1 opcode)3 opcNError
)~1,1(stmts 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 14(dot ~1 a 1 strVal)23 info
))
)5,2(elif
 13(infix
 == ~8(dot ~5 instr 1 opcode)3 opcNWarning
)~3,1(stmts
 7(call ~7 message 2(dot ~1 c 1 config)11 info 17 warnUser 28(dot
 ~1 a 1 strVal
))
)
)5,4(elif
 13(infix
 == ~8(dot ~5 instr 1 opcode)3 opcNHint
)~3,1(stmts
 7(call ~7 message 2(dot ~1 c 1 config)11 info 17 hintUser 28(dot
 ~1 a 1 strVal
))
)
)
)
)
),1338(of
(curlyConstr 3 opcParseExprToAst)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(var error . . 7 string 16"")4,2(let
 ast . . . 17(call
 ~11 parseString 14(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)24(dot ~1 c 1 cache)33(dot ~1 c 1 config)14,1(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)23,1 +0 6,2(proc
 . . . (params
 . 1(param conf . . 6 ConfigRef .)18(param
 info . . 6 TLineInfo .
)35(param msg . . 5 TMsgKind .)50(param
 arg . . 5 string .
)
). . ~3,1(stmts
 (if
 3(elif
 15(infix
 and ~5(infix
 == ~5(dot ~5 error 1 len)3 +0
)8(infix <= ~4 msg 3 errMax)
)~1,1(stmts
 6(asgn ~6 error 11(call
 ~9 formatMsg 1 conf 7 info 13 msg 18 arg
))
)
)
)
)
)
)
)14,8(asgn ~6(dot ~4(at ~4 regs 1 ra)1 node)9(call
 ~7 newNode 1 nkEmpty
)),9(if
 3(elif
 10(infix > ~5(dot
 ~5 error 1 len
)2 +0)~1,1(stmts
 12(asgn ~11(dot
 ~1 c 1 errorFlag
)2 error)
)
)5,2(elif
 8(infix
 != ~5(dot ~3 ast 1 len)3 +1
)~3,1(stmts
 12(asgn
 ~11(dot ~1 c 1 errorFlag)11(call
 ~9 formatMsg 2(dot
 ~1 c 1 config
)18(at ~6(dot ~1 c 1 debug)1 pc)24 errGenerated ~21,1"expected expression, but got multiple statements"
)
)
)
),5(else
 2,1(stmts 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)5(at ~3 ast 1 +0)
))
)
)
)
),1355(of
(curlyConstr 3 opcParseStmtToAst)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(var error . . 7 string 16"")4,2(let
 ast . . . 17(call
 ~11 parseString 14(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)24(dot ~1 c 1 cache)33(dot ~1 c 1 config)14,1(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)23,1 +0 6,2(proc
 . . . (params
 . 1(param conf . . 6 ConfigRef .)18(param
 info . . 6 TLineInfo .
)35(param msg . . 5 TMsgKind .)50(param
 arg . . 5 string .
)
). . ~3,1(stmts
 (if
 3(elif
 15(infix
 and ~5(infix
 == ~5(dot ~5 error 1 len)3 +0
)8(infix <= ~4 msg 3 errMax)
)~1,1(stmts
 6(asgn ~6 error 11(call
 ~9 formatMsg 1 conf 7 info 13 msg 18 arg
))
)
)
)
)
)
)
),7(if
 3(elif
 10(infix
 > ~5(dot ~5 error 1 len)2 +0
)~1,1(stmts
 12(asgn
 ~11(dot ~1 c 1 errorFlag)2 error
)14,1(asgn ~6(dot ~4(at ~4 regs 1 ra)1 node)9(call
 ~7 newNode 1 nkEmpty
))
)
),3(else 2,1(stmts
 14(asgn ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)2 ast)
))
)
)
),1368(of
(curlyConstr 3 opcQueryErrorFlag)2,1(stmts
 (cmd createStr 14(at
 ~4 regs 1 ra
))21,1(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)3(dot ~1 c 1 errorFlag)
)11,2(cmd (dot
 ~10(dot ~1 c 1 errorFlag)1 setLen
)8 +0)
)
),1372(of
(curlyConstr 3 opcCallSite)2,1(stmts
 10(call
 ~10 ensureKind 1 rkNode
),1(if
 3(elif
 11(infix
 != ~10(dot ~1 c 1 callsite)3(nil)
)19(stmts 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)3(dot ~1 c 1 callsite)
))
),1(else
 6(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"callsite"
)
)
)
)
)
)
),1376(of
(curlyConstr 3 opcNGetLineInfo)2,1(stmts
 10(call
 ~10 decodeBImm 1 rkNode
)4,1(let n . . . 12(dot
 ~4(at ~4 regs 1 rb)1 node
)),2(case
 5 imm ,1(of
(curlyConstr
 3 +0
)2,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)12(call
 ~10 newStrNode 1 nkStrLit 21(call
 ~10 toFullPath 2(dot
 ~1 c 1 config
)12(dot ~1 n 1 info)
)
)
)
)
),3(of
(curlyConstr 3 +1)2,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)12(call
 ~10 newIntNode 1 nkIntLit 22(dot ~5(dot
 ~5(dot ~1 n 1 info)1 line
)1 int)
)
)
)
),5(of
(curlyConstr 3 +2)2,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)12(call
 ~10 newIntNode 1 nkIntLit 21(dot ~4(dot
 ~5(dot ~1 n 1 info)1 col
)1 int)
)
)
)
),7(else
 2,1(stmts (cmd
 internalAssert 16(dot ~1 c 1 config)25 false
))
)
)19,11(asgn ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)3(dot
 ~1 n 1 info
))18,12(asgn
 ~5(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 typ
)3(dot ~1 n 1 typ)
)
)
),1390(of
(curlyConstr 3 opcNCopyLineInfo)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)19,1(asgn
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 info
)
)
)
),1393(of
(curlyConstr 3 opcNSetLineInfoLine)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)24,1(asgn
 ~6(dot
 ~5(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)1 line
)17(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 uint16)
)
)
),1396(of
(curlyConstr 3 opcNSetLineInfoColumn)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)23,1(asgn
 ~5(dot
 ~5(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)1 col
)17(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int16)
)
)
),1399(of
(curlyConstr 3 opcNSetLineInfoFile)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)29,1(asgn
 ~11(dot
 ~5(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)1 fileIndex
)~16,1(call
 ~11 fileInfoIdx 2(dot ~1 c 1 config)24(cmd ~13 RelativeFile 13(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
))
)
)
)
),1403(of
(curlyConstr 3 opcEqIdent)2,1(stmts
 8(call
 ~8 decodeBC 1 rkInt
)4,2(var aNode . . . 16(dot
 ~4(at ~4 regs 1 rb)1 node
))4,3(var
 bNode . . . 16(dot ~4(at
 ~4 regs 1 rc
)1 node)
),9(if
 3(elif
 11(infix
 == ~6(dot ~5 aNode 1 kind)3 nkPostfix
)~1,1(stmts 6(asgn
 ~6 aNode 7(at ~5 aNode 1 +1)
))
)
),11(if
 3(elif
 11(infix
 == ~6(dot ~5 aNode 1 kind)3 nkAccQuoted
)~1,1(stmts 6(asgn
 ~6 aNode 7(at ~5 aNode 1 +0)
))
)
),13(if
 3(elif
 11(infix
 == ~6(dot ~5 bNode 1 kind)3 nkPostfix
)~1,1(stmts 6(asgn
 ~6 bNode 7(at ~5 bNode 1 +1)
))
)
),15(if
 3(elif
 11(infix
 == ~6(dot ~5 bNode 1 kind)3 nkAccQuoted
)~1,1(stmts 6(asgn
 ~6 bNode 7(at ~5 bNode 1 +0)
))
)
)4,18(var aStrVal . . 9 cstring 19(nil))4,19(var
 bStrVal . . 9 cstring 19(nil)
),21(case
 10(dot ~5 aNode 1 kind),1(of
(curlyConstr 11(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))2,1(stmts 8(asgn
 ~8 aStrVal 14(dot ~7(dot
 ~5 aNode 1 strVal
)1 cstring)
))
),3(of
(curlyConstr 3 nkIdent)2,1(stmts
 8(asgn ~8 aStrVal 15(dot
 ~2(dot ~6(dot
 ~5 aNode 1 ident
)1 s)1 cstring
))
)
),5(of
(curlyConstr 3 nkSym)2,1(stmts
 8(asgn
 ~8 aStrVal 18(dot ~2(dot
 ~5(dot ~4(dot
 ~5 aNode 1 sym
)1 name)1 s
)1 cstring)
)
)
),7(of
(curlyConstr
 3 nkOpenSymChoice 20 nkClosedSymChoice
)2,1(stmts
 8(asgn
 ~8 aStrVal 21(dot
 ~2(dot
 ~5(dot ~4(dot
 ~3(at ~5 aNode 1 +0)1 sym
)1 name)1 s
)1 cstring
)
)
)
),9(else 2,1(stmts (discard .)))
),33(case
 10(dot ~5 bNode 1 kind),1(of
(curlyConstr 11(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))2,1(stmts 8(asgn
 ~8 bStrVal 14(dot ~7(dot
 ~5 bNode 1 strVal
)1 cstring)
))
),3(of
(curlyConstr 3 nkIdent)2,1(stmts
 8(asgn ~8 bStrVal 15(dot
 ~2(dot ~6(dot
 ~5 bNode 1 ident
)1 s)1 cstring
))
)
),5(of
(curlyConstr 3 nkSym)2,1(stmts
 8(asgn
 ~8 bStrVal 18(dot ~2(dot
 ~5(dot ~4(dot
 ~5 bNode 1 sym
)1 name)1 s
)1 cstring)
)
)
),7(of
(curlyConstr
 3 nkOpenSymChoice 20 nkClosedSymChoice
)2,1(stmts
 8(asgn
 ~8 bStrVal 21(dot
 ~2(dot
 ~5(dot ~4(dot
 ~3(at ~5 bNode 1 +0)1 sym
)1 name)1 s
)1 cstring
)
)
)
),9(else 2,1(stmts (discard .)))
)16,44(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~14,1(if
 3(elif
 15(infix and ~7(infix != ~8 aStrVal 3(nil))12(infix
 != ~8 bStrVal 3(nil)
))~1,1(stmts
 3(call
 ~3 ord 52(infix
 == ~30(call
 ~15(dot
 ~6 idents 1 cmpIgnoreStyle
)1 aStrVal 10 bStrVal 23(call ~4 high 1 int)
)3 +0
)
)
)
),2(else 2,1(stmts +0))
)
)
)
),1454(of
(curlyConstr 3 opcStrToIdent)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
),1(if
 3(elif
 19(infix
 notin ~6(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 kind)6(curlyConstr 9(infix
 .. ~8 nkStrLit 2 nkTripleStrLit
))
)~1,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"strVal"
))
)
),2(else
 2,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)10(call ~8 newNodeI 1 nkIdent 17(at
 ~6(dot ~1 c 1 debug)1 pc
))
)20,1(asgn
 ~7(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 ident)10(call
 ~8 getIdent 2(dot
 ~1 c 1 cache
)23(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)
)19,2(cmd
 (dot
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 flags)1 incl
)6 nfIsRef
)
)
)
)
)
),1462(of
(curlyConstr 3 opcSetType)2,1(stmts
 4(let
 typ . . . 13(at ~6(dot
 ~1 c 1 types
)13(infix
 - ~7(dot ~5 instr 1 regBx)2 wordExcess
))
),1(if
 3(elif
 14(infix != ~6(dot
 ~4(at ~4 regs 1 ra)1 kind
)3 rkNode)~1,1(stmts
 4(let
 temp . . . 16(call ~9 regToNode 5(at
 ~4 regs 1 ra
))
)10,1(call ~10 ensureKind 1 rkNode)14,2(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)2 temp
)19,3(asgn
 ~6(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 info)9(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)
)
)18,6(asgn
 ~5(dot ~5(dot
 ~4(at ~4 regs 1 ra)1 node
)1 typ)2 typ
)
)
),1470(of
(curlyConstr 3 opcConv)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
)),1(cmd inc 4 pc)4,2(let
 desttyp . . . 17(at
 ~6(dot
 ~1 c 1 types
)18(infix - ~7(dot
 ~4(at ~5(dot ~1 c 1 code)1 pc)1 regBx
)2 wordExcess)
)
),3(cmd inc 4 pc)4,4(let
 srctyp . . . 16(at
 ~6(dot ~1 c 1 types)18(infix
 - ~7(dot
 ~4(at ~5(dot
 ~1 c 1 code
)1 pc)1 regBx
)2 wordExcess
)
)
),6(if
 3(elif
 6(call
 ~6 opConv 1 c 8(at ~4 regs 1 ra)18(at
 ~4 regs 1 rb
)24 desttyp 33 srctyp
)~1,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 15,1(infix
 % ~23 errIllegalConvFromXtoY 2(bracketConstr
 ~13,1(call
 ~12 typeToString 1 srctyp
)9,1(call ~12 typeToString 1 desttyp)
)
)
)
)
)
)
)
),1481(of
(curlyConstr 3 opcCast)2,1(stmts
 4(let rb . . . 10(dot
 ~5 instr 1 regB
)),1(cmd inc 4 pc)4,2(let
 desttyp . . . 17(at
 ~6(dot
 ~1 c 1 types
)18(infix - ~7(dot
 ~4(at ~5(dot ~1 c 1 code)1 pc)1 regBx
)2 wordExcess)
)
),3(cmd inc 4 pc)4,4(let
 srctyp . . . 16(at
 ~6(dot ~1 c 1 types)18(infix
 - ~7(dot
 ~4(at ~5(dot
 ~1 c 1 code
)1 pc)1 regBx
)2 wordExcess
)
)
),6(when
 5(elif
 hasFFI ~3,1(stmts
 4(let
 dest . . . 14(call
 ~7 fficast 2(dot ~1 c 1 config)19(dot ~4(at
 ~4 regs 1 rb
)1 node)26 desttyp
)
)10,3(call
 ~10 putIntoReg 5(at ~4 regs 1 ra)11 dest
)
)
),5(else
 2,1(stmts
 11(call
 ~11 globalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"cannot evaluate cast"
)
)
)
)
)
),1495(of
(curlyConstr 3 opcNSetIntVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),2(if
 3(elif
 38(infix
 and ~28(infix
 in ~6(dot
 ~4 dest 1 kind
)3(curlyConstr
 10(infix .. ~9 nkCharLit 2 nkUInt64Lit)
)
)~24,1(infix
 in ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3(curlyConstr 1 rkInt)
)
)~1,2(stmts 12(asgn
 ~8(dot ~4 dest 1 intVal)10(dot ~4(at
 ~4 regs 1 rb
)1 intVal)
))
)5,3(elif
 19(infix
 and ~9(infix
 == ~6(dot ~4 dest 1 kind)3 nkSym
)18(infix == ~6(dot
 ~4(dot ~4 dest 1 sym)1 kind
)3 skEnumField)
)~3,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 13"`intVal` cannot be changed for an enum symbol."
)
)
),5(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"intVal"
))
)
)
)
)
),1505(of
(curlyConstr 3 opcNSetFloatVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),2(if
 3(elif
 40(infix
 and ~30(infix
 in ~6(dot
 ~4 dest 1 kind
)3(curlyConstr
 11(infix .. ~10 nkFloatLit 2 nkFloat64Lit)
)
)~26,1(infix
 in ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3(curlyConstr 1 rkFloat)
)
)~1,2(stmts
 14(asgn
 ~10(dot ~4 dest 1 floatVal)10(dot ~4(at
 ~4 regs 1 rb
)1 floatVal)
)
)
),3(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"floatVal"
)
)
)
)
)
)
),1513(of
(curlyConstr 3 opcNSetSymbol)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),2(if
 3(elif
 19(infix
 and ~9(infix == ~6(dot
 ~4 dest 1 kind
)3 nkSym)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkSym)
)~1,1(stmts
 9(asgn ~5(dot ~4 dest 1 sym)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 sym
))
)
),2(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"symbol"
))
)
)
)
)
),1520(of
(curlyConstr 3 opcNSetIdent)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),2(if
 3(elif
 21(infix
 and ~11(infix == ~6(dot
 ~4 dest 1 kind
)3 nkIdent)23(infix == ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 kind
)3 nkIdent)
)~1,1(stmts
 11(asgn
 ~7(dot ~4 dest 1 ident)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 ident
)
)
)
),2(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"ident"
))
)
)
)
)
),1527(of
(curlyConstr 3 opcNSetStrVal)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var dest . . . 15(dot
 ~4(at ~4 regs 1 ra)1 node
)),2(if
 3(elif
 40(infix
 and ~30(infix
 in ~6(dot
 ~4 dest 1 kind
)3(curlyConstr
 9(infix .. ~8 nkStrLit 2 nkTripleStrLit)
)
)~26,1(infix
 in ~6(dot
 ~4(at ~4 regs 1 rb)1 kind
)3(curlyConstr 1 rkNode)
)
)~1,2(stmts
 12(asgn
 ~8(dot ~4 dest 1 strVal)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)
)
)5,3(elif
 27(infix
 and ~17(infix
 == ~6(dot ~4 dest 1 kind)3 nkCommentStmt
)18(infix in ~6(dot ~4(at ~4 regs 1 rb)1 kind)3(curlyConstr
 1 rkNode
))
)~3,1(stmts
 13(asgn
 ~9(dot ~4 dest 1 comment)15(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)
)
),5(else
 2,1(stmts
 10(call ~10 stackTrace 1 c 4 tos 9 pc 31(infix
 & ~18 errFieldXNotFound 2"strVal"
))
)
)
)
)
),1537(of
(curlyConstr 3 opcNNewNimNode)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(var k . . . 12(dot
 ~4(at ~4 regs 1 rb)1 intVal
)),2(if
 3(elif
 6(infix
 or ~4(infix
 < ~2 k 2 +0
)5(infix > ~2 k 5(call
 ~3 ord 5(call ~4 high 1 TNodeKind)
))
)~1,1(stmts
 13(call
 ~13 internalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)~11,1"request to create a NimNode of invalid kind"
)
)
)
)4,5(let cc . . . 13(dot
 ~4(at ~4 regs 1 rc)1 node
))4,7(let
 x . . . 12(call
 ~8 newNodeI 10(call ~9 TNodeKind 4(call
 ~3 int 1 k
))~14,1(if
 3(elif
 8(infix != ~6(dot
 ~2 cc 1 kind
)3 nkNilLit)~1,1(stmts 2(dot
 ~2 cc 1 info
))
)5,2(elif
 26(infix != ~6(dot
 ~19(dot ~1 c 1 comesFromHeuristic)1 line
)3 +0u16)~3,1(stmts 1(dot
 ~1 c 1 comesFromHeuristic
))
)5,4(elif
 18(infix
 and ~7(infix
 != ~10(dot ~1 c 1 callsite)3(nil)
)23(infix > ~9(dot
 ~9(dot ~1 c 1 callsite)1 safeLen
)2 +1)
)~3,1(stmts
 13(dot ~3(at
 ~9(dot ~1 c 1 callsite)1 +1
)1 info)
)
),6(else 2,1(stmts
 7(at ~6(dot ~1 c 1 debug)1 pc)
))
)
)
)7,16(cmd
 (dot ~6(dot ~1 x 1 flags)1 incl)6 nfIsRef
),18(if
 3(elif
 7(infix
 == ~6(dot ~1 x 1 kind)3 nkIdent
)19(stmts
 8(asgn ~7(dot ~1 x 1 ident)9(dot
 ~6(dot ~1 c 1 cache)1 emptyIdent
))
)
)
)14,19(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)2 x
)
)
),1558(of
(curlyConstr 3 opcNCopyNimNode)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)10(call
 ~8 copyNode 9(dot ~4(at
 ~4 regs 1 rb
)1 node)
)
)
)
),1561(of
(curlyConstr 3 opcNCopyNimTree)2,1(stmts
 7(call
 ~7 decodeB 1 rkNode
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)10(call
 ~8 copyTree 9(dot ~4(at
 ~4 regs 1 rb
)1 node)
)
)
)
),1564(of
(curlyConstr 3 opcNDel)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let
 bb . . . 20(dot ~7(dot
 ~4(at ~4 regs 1 rb)1 intVal
)1 int)
)4,2(for
 6(infix
 ..< ~1 +0 18(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)(unpackIntoFlat(let i ....))~2,1(stmts 6(call
 ~6 delSon 9(dot ~4(at
 ~4 regs 1 ra
)1 node)16 bb
))
)
)
),1569(of
(curlyConstr 3 opcGenSym)2,1(stmts
 8(call
 ~8 decodeBC 1 rkNode
)4,1(let k . . . 12(dot
 ~4(at ~4 regs 1 rb)1 intVal
))4,2(let
 name . . . 7(if
 3(elif
 25(infix
 == ~5(dot ~7(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)1 len)3 +0
)31(stmts "\3Atmp")
),1(else 6(stmts
 13(dot ~5(dot
 ~4(at ~4 regs 1 rc)1 node
)1 strVal)
))
)
),4(if
 3(elif
 6(infix
 or ~4(infix < ~2 k 2 +0)5(infix
 > ~2 k 5(call ~3 ord 5(call
 ~4 high 1 TSymKind
))
)
)~1,1(stmts
 13(call
 ~13 internalError 2(dot ~1 c 1 config)18(at ~6(dot
 ~1 c 1 debug
)1 pc)24"request to create symbol of invalid kind"
)
)
)
)4,6(var
 sym . . . 12(call
 ~6 newSym 2(dot ~1 k 1 TSymKind)21(call ~8 getIdent 2(dot
 ~1 c 1 cache
)10 name)39(dot
 ~1 c 1 idgen
)55(dot ~7(dot ~1 c 1 module)1 owner)70(at ~6(dot
 ~1 c 1 debug
)1 pc)
)
)4,7(call
 ~4 incl 4(dot ~3 sym 1 flags)12 sfGenSym
)14,8(asgn ~6(dot ~4(at ~4 regs 1 ra)1 node)12(call
 ~10 newSymNode 1 sym
))19,9(cmd
 (dot ~6(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 flags
)1 incl)6 nfIsRef
)
)
),1580(of
(curlyConstr 3 opcNccValue)2,1(stmts
 7(call
 ~7 decodeB 1 rkInt
)12,1(let
 ~8 destKey . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)16,2(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)14(call
 ~12 getOrDefault 8(dot
 ~6(dot ~1 c 1 graph)1 cacheCounters
)24 destKey
)
)
)
),1584(of
(curlyConstr 3 opcNccInc)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))6,1(call ~6 declBC)12,2(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)4,3(let by . . . 13(dot
 ~4(at ~4 regs 1 rc)1 intVal
))4,4(let
 v . . . 16(call ~12 getOrDefault 2(dot
 ~1 g 1 cacheCounters
)18 destKey)
)25,5(asgn
 ~10(at
 ~14(dot ~1 g 1 cacheCounters)1 destKey
)3(infix + ~1 v 1 by)
)9,6(call
 ~9 recordInc 1 c 11(at
 ~6(dot ~1 c 1 debug)1 pc
)17 destKey 26 by
)
)
),1592(of
(curlyConstr 3 opcNcsAdd)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))6,1(call ~6 declBC)12,2(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)4,3(let val . . . 14(dot
 ~4(at ~4 regs 1 rc)1 node
)),4(if
 3(elif
 (prefix
 not 12(call ~8 contains 2(dot
 ~1 g 1 cacheSeqs
)14 destKey)
)~1,1(stmts
 21(asgn
 ~10(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)9(call ~7 newTree 1 nkStmtList 13 val)
)
)
),2(else
 2,1(stmts 20(cmd
 (dot ~9(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)1 add)5 val
))
)
)9,8(call
 ~9 recordAdd 1 c 11(at
 ~6(dot ~1 c 1 debug)1 pc
)17 destKey 26 val
)
)
),1602(of
(curlyConstr 3 opcNcsIncl)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))6,1(call ~6 declBC)12,2(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)4,3(let val . . . 14(dot
 ~4(at ~4 regs 1 rc)1 node
)),4(if
 3(elif
 (prefix
 not 12(call ~8 contains 2(dot
 ~1 g 1 cacheSeqs
)14 destKey)
)~1,1(stmts
 21(asgn
 ~10(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)9(call ~7 newTree 1 nkStmtList 13 val)
)
)
),2(else
 2,1(stmts
 (block
 6 search 2,1(stmts
 4(for
 23(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)(unpackIntoFlat(let existing ....))~2,1(stmts
 (if
 3(elif
 24(call
 ~24 exprStructuralEquivalent 1 existing 11 val 33(vv
 ~17 strictSymEquality 1 true
)
)~1,1(stmts (brk 6 search))
)
)
)
)20,3(cmd
 (dot ~9(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)1 add)5 val
)
)
)
)
)
)10,12(call
 ~10 recordIncl 1 c 11(at
 ~6(dot ~1 c 1 debug)1 pc
)17 destKey 26 val
)
)
),1616(of
(curlyConstr 3 opcNcsLen)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))7,1(call ~7 decodeB 1 rkInt)12,2(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~14,1(if
 3(elif
 8(call
 ~8 contains 2(dot ~1 g 1 cacheSeqs)14 destKey
)32(stmts
 20(dot ~9(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)1 len)
)
)60(else 6(stmts +0))
)
)
)
),1622(of
(curlyConstr 3 opcNcsAt)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))8,1(call
 ~8 decodeBC 1 rkNode
)4,2(let idx . . . 14(dot
 ~4(at ~4 regs 1 rc)1 intVal
))12,3(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
),4(if
 3(elif
 31(infix
 and ~23(call
 ~8 contains 2(dot ~1 g 1 cacheSeqs)14 destKey
)8(infix
 <% ~4 idx 23(dot ~9(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)1 len)
)
)~1,1(stmts
 14(asgn
 ~6(dot
 ~4(at ~4 regs 1 ra)1 node
)22(at
 ~9(at
 ~10(dot ~1 g 1 cacheSeqs)1 destKey
)4(dot ~3 idx 1 int)
)
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 34(call
 ~21 formatErrorIndexBound 1 idx 30(infix - ~4(dot
 ~9(at ~10(dot
 ~1 g 1 cacheSeqs
)1 destKey)1 len
)1 +1)
)
)
)
)
)
)
),1631(of
(curlyConstr 3 opcNctPut)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))12,1(let
 ~8 destKey . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)
)8,2(let
 ~4 key . (pragmas 2 cursor). 34(dot ~5(dot
 ~12(at ~4 regs 6(dot
 ~5 instr 1 regB
))1 node
)1 strVal)
)4,3(let
 val . . . 22(dot ~12(at
 ~4 regs 6(dot ~5 instr 1 regC)
)1 node)
),4(if
 3(elif
 (prefix not 12(call
 ~8 contains 2(dot ~1 g 1 cacheTables)16 destKey
))~1,1(stmts
 23(asgn
 ~10(at ~12(dot
 ~1 g 1 cacheTables
)1 destKey)26(call ~15(at
 ~9 initBTree 1 string 9 PNode
))
)
)
)
),6(if
 3(elif
 (prefix
 not 12(call ~8 contains 14(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)25 key)
)~1,1(stmts
 26(call
 ~4(dot ~9(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)1 add)1 key 6 val
)9,1(call
 ~9 recordPut 1 c 11(at
 ~6(dot ~1 c 1 debug)1 pc
)17 destKey 26 key 31 val
)
)
),3(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 36(infix
 & ~23"key already exists\3A " 2 key
)
)
)
)
)
)
),1643(of
(curlyConstr 3 opcNctLen)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))7,1(call ~7 decodeB 1 rkInt)12,2(let
 ~8 destKey . (pragmas
 2 cursor
). 26(dot
 ~5(dot ~4(at ~4 regs 1 rb)1 node)1 strVal
)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~14,1(if
 3(elif
 8(call
 ~8 contains 2(dot ~1 g 1 cacheTables)16 destKey
)34(stmts
 22(dot ~9(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)1 len)
)
)64(else 6(stmts +0))
)
)
)
),1649(of
(curlyConstr 3 opcNctGet)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))8,1(call
 ~8 decodeBC 1 rkNode
)12,2(let
 ~8 destKey . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)8,3(let
 ~4 key . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 rc
)1 node)1 strVal
)
),4(if
 3(elif
 8(call
 ~8 contains 2(dot ~1 g 1 cacheTables)16 destKey
)~1,1(stmts
 (if
 3(elif
 8(call ~8 contains 14(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)25 key)~1,1(stmts
 14(asgn
 ~6(dot ~4(at
 ~4 regs 1 ra
)1 node)14(call
 ~12 getOrDefault 14(at ~12(dot
 ~1 g 1 cacheTables
)1 destKey)25 key
)
)
)
),2(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 36(infix
 & ~23"key does not exist\3A " 2 key
)
)
)
)
)
)
),5(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 36(infix
 & ~23"key does not exist\3A " 2 destKey
)
)
)
)
)
)
),1661(of
(curlyConstr 3 opcNctHasNext)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))8,1(call
 ~8 decodeBC 1 rkInt
)12,2(let
 ~8 destKey . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)16,3(asgn
 ~8(dot
 ~4(at ~4 regs 1 ra)1 intVal
)~14,1(if
 3(elif
 22(call ~9(dot
 ~12(dot ~1 g 1 cacheTables)1 contains
)1 destKey)~1,1(stmts
 3(call
 ~3 ord 15(call
 ~8(dot
 ~6 btrees 1 hasNext
)14(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)40(dot ~7(dot
 ~4(at ~4 regs 1 rc)1 intVal
)1 int)
)
)
)
),2(else 2,1(stmts +0))
)
)
)
),1670(of
(curlyConstr 3 opcNctNext)2,1(stmts
 4(let g . . . 5(dot
 ~1 c 1 graph
))8,1(call
 ~8 decodeBC 1 rkNode
)12,2(let
 ~8 destKey . (pragmas 2 cursor). 26(dot
 ~5(dot ~4(at
 ~4 regs 1 rb
)1 node)1 strVal
)
)4,3(let index . . . 16(dot
 ~4(at ~4 regs 1 rc)1 intVal
)),4(if
 3(elif
 8(call ~8 contains 2(dot
 ~1 g 1 cacheTables
)16 destKey)~1,1(stmts
 4(unpackDecl
31(call
 ~5(dot
 ~6 btrees 1 next
)14(at
 ~12(dot ~1 g 1 cacheTables)1 destKey
)30(dot ~5 index 1 int)
)(unpackIntoTuple
(let1 k ....)(let4 v ....)(let7 nextIndex ....)
)
)14,1(asgn
 ~6(dot ~4(at ~4 regs 1 ra)1 node)9(call
 ~7 newTree 1 nkTupleConstr 26(call
 ~10 newStrNode 1 k 11(at ~6(dot
 ~1 c 1 debug
)1 pc)
)44 v 11,1(call
 ~10 newIntNode 1 nkIntLit 11 nextIndex
)
)
)
)
),4(else
 2,1(stmts
 10(call
 ~10 stackTrace 1 c 4 tos 9 pc 36(infix
 & ~23"key does not exist\3A " 2 destKey
)
)
)
)
)
)
),1682(of
(curlyConstr 3 opcTypeTrait)2,3(stmts
 7(call
 ~7 decodeB 1 rkNode
)4,1(var
 typ . . . 19(dot ~5(dot
 ~4(at ~4 regs 1 rb)1 node
)1 typ)
),2(cmd internalAssert 16(dot ~1 c 1 config)29(infix
 != ~4 typ 3(nil)
)),3(while
 29(infix
 and ~14(infix == ~6(dot
 ~3 typ 1 kind
)3 tyTypeDesc)7(dot
 ~3 typ 1 hasElementType
)
)53(stmts 4(asgn
 ~4 typ 5(dot ~3 typ 1 skipModifier)
))
),4(cmd createStr 14(at ~4 regs 1 ra))21,5(asgn
 ~8(dot
 ~5(dot ~4(at
 ~4 regs 1 ra
)1 node)1 strVal
)18(call
 ~13(dot ~3 typ 1 typeToString)1 preferExported
)
)
)
)
)16,1710(call ~6(dot
 ~9(dot ~1 c 1 profiler)1 leave
)1 c),1712(cmd
 inc 4 pc
)
)
)
)
),2273(proc
 5 execute . . . 12(params 23 PNode 1(param c . . 3 PCtx .)10(param
 start . . 7 int .
)). . 2,1(stmts
 4(var
 tos . . . 17(objConstr
 ~11 PStackFrame 4(kv
 ~3 prc 2(nil)
)20(kv ~9 comesFrom 2 +0)29(kv ~4 next 2(nil))
)
)6,1(call
 ~6 newSeq 4(dot ~3 tos 1 slots)25(dot
 ~8(dot ~4(dot
 ~1 c 1 prc
)1 regInfo)1 len
)
)7,2(asgn
 ~7 result 27(dot ~15(call
 ~10 rawExecute 1 c 4 start 11 tos
)1 regToNode)
)
)
),2278(proc
 5 execProc x . . 14(params
 46 PNode 1(param c . . 3 PCtx .)10(param
 sym . . 5 PSym .
)21(param
 args . . 15(at ~9 openArray 1 PNode).
)
). . 2,1(stmts
 17(asgn
 ~16(dot ~1 c 1 loopIterations)10(dot ~7(dot
 ~1 c 1 config
)1 maxLoopIterationsVM)
),1(if
 3(elif
 9(infix
 in ~6(dot ~3 sym 1 kind)3 routineKinds
)~1,1(stmts
 (if
 3(elif
 18(infix
 != ~11(dot
 ~4(dot ~3 sym 1 typ)1 paramsLen
)7(dot ~4 args 1 len)
)~1,1(stmts
 7(asgn ~7 result 2(nil))10,1(call
 ~10 localError 2(dot
 ~1 c 1 config
)14(dot ~3 sym 1 info)39,1(infix
 % ~47"NimScript\3A expected $\23 arguments, but got $\23" 2(bracketConstr
 ~49,1(prefix $ 1(par
 8(dot ~4(dot
 ~3 sym 1 typ
)1 paramsLen)
))~27,1(prefix $ 5(dot
 ~4 args 1 len
))
)
)
)
)
),5(else
 2,1(stmts
 4(let
 start . . . 15(call ~7 genProc 1 c 4 sym)
)4,2(var
 tos . . . 17(objConstr
 ~11 PStackFrame 4(kv ~3 prc 2 sym)20(kv
 ~9 comesFrom 2 +0
)29(kv ~4 next 2(nil))
)
)4,3(let
 maxSlots . . . 14(dot ~3 sym 1 offset)
)6,4(call
 ~6 newSeq 4(dot ~3 tos 1 slots)12 maxSlots
),7(if
 3(elif
 36(infix
 or ~36(prefix
 not 15(call ~11 isEmptyType 8(dot
 ~4(dot ~3 sym 1 typ)1 returnType
))
)12(infix
 == ~6(dot ~3 sym 1 kind)3 skMacro
)
)~1,1(stmts
 10(call
 ~10 putIntoReg 10(at
 ~6(dot ~3 tos 1 slots)1 +0
)27(call
 ~12 getNullValue 8(dot
 ~4(dot ~3 sym 1 typ)1 returnType
)24(dot ~3 sym 1 info)32(dot ~1 c 1 config)
)
)
)
)
)4,10(for
 6(infix ..< ~1 +0 10(dot
 ~4(dot ~3 sym 1 typ)1 paramsLen
))(unpackIntoFlat
(let i ....)
)~2,1(stmts
 10(call
 ~10 putIntoReg 10(at ~6(dot ~3 tos 1 slots)2(infix
 + ~1 i 1 +1
))21(at ~4 args 1 i)
)
)
)7,13(asgn
 ~7 result 27(dot ~15(call
 ~10 rawExecute 1 c 4 start 11 tos
)1 regToNode)
)
)
)
)
)
),21(else
 2,1(stmts
 7(asgn ~7 result 2(nil))10,1(call
 ~10 localError 2(dot
 ~1 c 1 config
)14(dot ~3 sym 1 info)35,1(infix
 & ~43"NimScript\3A attempt to call non-routine\3A " 10(dot ~5(dot
 ~3 sym 1 name
)1 s)
)
)
)
)
)
)
),2306(proc
 5 evalStmt x . . 14(params . 1(param c . . 3 PCtx .)10(param
 n . . 3 PNode .
)). . 2,1(stmts
 4(let
 n . . . 17(call
 ~13 transformExpr 2(dot
 ~1 c 1 graph
)11(dot ~1 c 1 idgen)20(dot ~1 c 1 module)29 n
)
)4,1(let
 start . . . 15(call ~7 genStmt 1 c 4 n)
),4(if
 3(elif
 21(infix
 != ~8(dot ~7(at
 ~5(dot ~1 c 1 code)1 start
)1 opcode)3 opcEof
)~1,1(stmts (discard
 15(call ~7 execute 1 c 4 start)
))
)
)
)
),2314(proc
 5 evalExpr x . . 14(params 21 PNode 1(param c . . 3 PCtx .)10(param
 n . . 3 PNode .
)). . 2,4(stmts
 4(let
 n . . . 17(call
 ~13 transformExpr 2(dot
 ~1 c 1 graph
)11(dot ~1 c 1 idgen)20(dot ~1 c 1 module)29 n
)
)4,1(let
 start . . . 15(call ~7 genExpr 1 c 4 n)
),2(cmd
 assert 28(infix
 != ~8(dot ~7(at
 ~5(dot ~1 c 1 code)1 start
)1 opcode)3 opcEof
)
)7,3(asgn
 ~7 result 9(call ~7 execute 1 c 4 start)
)
)
),2323(proc
 5 getGlobalValue x . . 20(params 20 PNode 1(param c . . 3 PCtx .)10(param
 s . . 3 PSym .
)). . 2,1(stmts
 (cmd
 internalAssert 16(dot
 ~1 c 1 config
)50(infix
 and ~18(infix in ~6(dot ~1 s 1 kind)3(curlyConstr
 1 skLet 8 skVar
))13(infix in ~9 sfGlobal 4(dot
 ~1 s 1 flags
))
)
)7,1(asgn
 ~7 result 11(at
 ~8(dot ~1 c 1 globals)11(infix - ~9(dot
 ~1 s 1 position
)1 +1)
)
)
)
),2327(proc
 5 setGlobalValue x . . 20(params
 . 1(param c . . 3 PCtx .)10(param
 s . . 3 PSym .
)19(param val . . 5 PNode .)
). . 2,1(stmts
 (comment),1(cmd
 internalAssert 16(dot ~1 c 1 config)50(infix
 and ~18(infix
 in ~6(dot
 ~1 s 1 kind
)3(curlyConstr 1 skLet 8 skVar)
)13(infix
 in ~9 sfGlobal 4(dot ~1 s 1 flags)
)
)
)24,2(asgn
 ~15(at
 ~8(dot ~1 c 1 globals)11(infix - ~9(dot
 ~1 s 1 position
)1 +1)
)2 val
)
)
),2332(include 8 vmops),2334(proc
 5 setupGlobalCtx x . . 20(params
 . 1(param
 module . . 8 PSym .
)15(param graph . . 7 ModuleGraph .)35(param
 idgen . . 7 IdGenerator .
)
). . 2,1(stmts
 (if
 3(elif
 8(dot
 ~3(dot ~5 graph 1 vm)1 isNil
)~1,1(stmts
 9(asgn
 ~4(dot ~5 graph 1 vm)8(call
 ~6 newCtx 1 module 14(dot
 ~5 graph 1 cache
)22 graph 29 idgen
)
)21,1(call ~21 registerAdditionalOps 6(cmd
 ~5 PCtx 5(dot ~5 graph 1 vm)
))
)
),3(else
 2,1(stmts
 7(call
 ~7 refresh 6(cmd
 ~5 PCtx 5(dot ~5 graph 1 vm)
)16 module 24 idgen
)
)
)
)
)
),2341(proc
 5 setupEvalGen x . . 18(params
 56 PPassContext 1(param
 graph . . 7 ModuleGraph .
)21(param module . . 8 PSym .)35(param
 idgen . . 7 IdGenerator .
)
). . 2,6(stmts
 14(call
 ~14 setupGlobalCtx 1 module 9 graph 16 idgen
)7,1(asgn ~7 result 7(cmd
 ~5 PCtx 5(dot ~5 graph 1 vm)
))
)
),2350(proc
 5 interpreterCode x . . 21(params
 29 PNode 1(param
 c . . 3 PPassContext .
)18(param n . . 3 PNode .)
). . 2,1(stmts
 4(let
 c . . . 8(call ~4 PCtx 1 c)
),2(if
 3(elif
 16(infix
 == ~15(dot ~1 c 1 oldErrorCount)11(dot ~7(dot
 ~1 c 1 config
)1 errorCounter)
)~1,1(stmts
 8(call ~8 evalStmt 1 c 4 n)7,1(asgn
 ~7 result 10(call ~8 newNodeI 1 nkEmpty 11(dot
 ~1 n 1 info
))
)
)
),3(else
 2,1(stmts 7(asgn ~7 result 2 n))
)
)16,7(asgn
 ~15(dot ~1 c 1 oldErrorCount)10(dot ~7(dot
 ~1 c 1 config
)1 errorCounter)
)
)
),2360(proc
 5 evalConstExprAux . . . 21(params
 19,2 PNode 1(param
 module . . 8 PSym .
)15(param idgen . . 7 IdGenerator .)1,1(param
 g . . 3 ModuleGraph .
)17,1(param prc . . 5 PSym .)28,1(param
 n . . 3 PNode .
)1,2(param mode . . 6 TEvalMode .)
). . 2,3(stmts
 (when
 5(elif
 7(call ~7 defined 1 nimsuggest)~3,1(stmts
 (if
 3(elif
 19(call
 ~11(dot ~7(dot
 ~1 g 1 config
)1 expandDone)
)~1,1(stmts (ret 7 n))
)
)
)
)
)4,4(let n . . . 17(call
 ~13 transformExpr 1 g 4 idgen 11 module 19 n
))14,5(call
 ~14 setupGlobalCtx 1 module 9 g 12 idgen
)4,6(var
 c . . . 9(cmd ~5 PCtx 1(dot ~1 g 1 vm))
)4,7(let
 oldMode . . . 11(dot ~1 c 1 mode)
)7,8(asgn ~6(dot ~1 c 1 mode)2 mode)4,9(let
 start . . . 15(call
 ~7 genExpr 1 c 4 n 21(vv ~14 requiresValue 6(infix
 != ~4 mode 2 emStaticStmt
))
)
),10(if
 3(elif
 21(infix
 == ~8(dot ~7(at
 ~5(dot ~1 c 1 code)1 start
)1 opcode)3 opcEof
)32(stmts
 (ret 15(call
 ~8 newNodeI 1 nkEmpty 11(dot ~1 n 1 info)
))
)
)
),11(cmd
 assert 28(infix
 != ~8(dot ~7(at
 ~5(dot ~1 c 1 code)1 start
)1 opcode)3 opcEof
)
),12(when 5(elif
 debugEchoCode 15(stmts 1(cmd
 (dot ~1 c 1 echoCode)10 start
))
))4,13(var
 tos . . . 17(objConstr
 ~11 PStackFrame 4(kv
 ~3 prc 2 prc
)20(kv ~9 comesFrom 2 +0)29(kv ~4 next 2(nil))
)
)6,14(call
 ~6 newSeq 4(dot ~3 tos 1 slots)25(dot
 ~8(dot ~4(dot
 ~1 c 1 prc
)1 regInfo)1 len
)
)7,16(asgn
 ~7 result 27(dot ~15(call
 ~10 rawExecute 1 c 4 start 11 tos
)1 regToNode)
),17(if
 3(elif
 16(infix < ~5(dot
 ~5(dot ~6 result 1 info)1 col
)2 +0)21(stmts 12(asgn
 ~6(dot
 ~6 result 1 info
)3(dot ~1 n 1 info)
))
)
)7,18(asgn
 ~6(dot ~1 c 1 mode)2 oldMode
)
)
),2383(proc
 5 evalConstExpr x . . 19(params
 62 PNode 1(param
 module . . 8 PSym .
)15(param idgen . . 7 IdGenerator .)35(param
 g . . 3 ModuleGraph .
)51(param e . . 3 PNode .)
). . 2,1(stmts
 7(asgn
 ~7 result 18(call
 ~16 evalConstExprAux 1 module 9 idgen 16 g 19(nil)24 e 27 emConst
)
)
)
),2386(proc
 5 evalStaticExpr x . . 20(params
 73 PNode 1(param
 module . . 8 PSym .
)15(param idgen . . 7 IdGenerator .)35(param
 g . . 3 ModuleGraph .
)51(param e . . 3 PNode .)61(param prc . . 5 PSym .)
). . 2,1(stmts
 7(asgn
 ~7 result 18(call
 ~16 evalConstExprAux 1 module 9 idgen 16 g 19 prc 24 e 27 emStaticExpr
)
)
)
),2389(proc
 5 evalStaticStmt x . . 20(params
 . 1(param module . . 8 PSym .)15(param
 idgen . . 7 IdGenerator .
)35(param g . . 3 ModuleGraph .)51(param
 e . . 3 PNode .
)61(param prc . . 5 PSym .)
). . 2,1(stmts
 (discard
 24(call
 ~16 evalConstExprAux 1 module 9 idgen 16 g 19 prc 24 e 27 emStaticStmt
)
)
)
),2392(proc
 5 setupCompileTimeVar x . . 25(params
 . 1(param
 module . . 8 PSym .
)15(param idgen . . 7 IdGenerator .)35(param
 g . . 3 ModuleGraph .
)51(param n . . 3 PNode .)
). . 2,1(stmts
 (discard
 24(call
 ~16 evalConstExprAux 1 module 9 idgen 16 g 19(nil)24 n 27 emStaticStmt
)
)
)
),2395(proc
 5 prepareVMValue . . . 19(params 14 PNode 1(param
 arg . . 5 PNode .
)). . 2,1(stmts
 (comment),4(if
 3(elif 9(infix in ~6(dot
 ~3 arg 1 kind
)3 nkLiterals)~1,1(stmts
 (ret 7 arg)
))
),7(if
 3(elif
 22,1(infix
 and 28,-1(infix
 and ~22(infix
 and ~19(infix
 == ~6(dot ~3 arg 1 kind)3 nkExprColonExpr
)15(infix
 != ~5(dot ~3(at ~3 arg 1 +0)1 typ)3(nil)
)
)~35,1(infix != ~5(dot
 ~4(dot ~3(at ~3 arg 1 +0)1 typ)1 sym
)3(nil))
)25(infix
 == ~7(dot ~4(dot
 ~4(dot ~3(at ~3 arg 1 +0)1 typ)1 sym
)1 magic)3 mPNimrodNode
)
)~1,4(stmts (ret 7 arg))
)
)7,13(asgn
 ~7 result 10(call ~8 copyNode 1 arg)
),14(if
 3(elif
 9(infix
 == ~6(dot ~3 arg 1 kind)3 nkTupleConstr
)~1,1(stmts
 4(for
 9 arg(unpackIntoFlat(let child ....))~2,1(stmts
 (if
 3(elif
 11(infix == ~6(dot
 ~5 child 1 kind
)3 nkExprColonExpr)~1,1(stmts
 6(cmd (dot
 ~6 result 1 add
)19(call
 ~14 prepareVMValue 6(at ~5 child 1 +1)
))
)
),2(else
 2,1(stmts
 6(cmd (dot ~6 result 1 add)19(call
 ~14 prepareVMValue 1 child
))
)
)
)
)
)
)
),6(else
 2,1(stmts
 4(for
 9 arg(unpackIntoFlat(let child ....))~2,1(stmts 6(cmd
 (dot
 ~6 result 1 add
)19(call ~14 prepareVMValue 1 child)
))
)
)
)
)
)
),2420(proc
 5 setupMacroParam . . . 20(params
 24 TFullReg 1(param
 x . . 3 PNode .
)11(param typ . . 5 PType .)
). . 2,1(stmts
 (case
 8(dot ~3 typ 1 kind),1(of
(curlyConstr 3 tyStatic)2,1(stmts
 7(asgn
 ~7 result 10(objConstr ~8 TFullReg 5(kv
 ~4 kind 2 rkNone
))
)10,1(call ~10 putIntoReg 1 result 23(call
 ~14 prepareVMValue 1 x
))
)
),4(else
 2,1(stmts
 4(var n . . . 4 x),1(if
 3(elif
 7(infix
 in ~6(dot
 ~1 n 1 kind
)3(curlyConstr
 1 nkHiddenSubConv 18 nkHiddenStdConv
)
)46(stmts
 2(asgn ~2 n 3(at ~1 n 1 +1))
)
)
)7,2(cmd
 (dot ~6(dot ~1 n 1 flags)1 incl)6 nfIsRef
)6,3(asgn
 ~5(dot ~1 n 1 typ)3(dot ~1 x 1 typ)
)7,4(asgn
 ~7 result 10(objConstr ~8 TFullReg 5(kv ~4 kind 2 rkNode)19(kv
 ~4 node 2 n
))
)
)
)
)
)
),2432(iterator
 9 genericParamsInMacroCall x . . 34(params
 31(tupleConstr
 1 PSym 7 PNode
)1(param macroSym . . 10 PSym .)17(param
 call . . 6 PNode .
)
). . 2,1(stmts
 4(let gp . . . 17(at
 ~4(dot ~8 macroSym 1 ast)1 genericParamsPos
))4,1(for
 6(infix ..< ~1 +0 5(dot
 ~2 gp 1 len
))(unpackIntoFlat(let i ....))~2,1(stmts
 4(let
 genericParam . . . 20(dot ~3(at
 ~2 gp 1 i
)1 sym)
)4,1(let
 posInCall . . . 38(infix + ~14(dot
 ~4(dot ~8 macroSym 1 typ)1 signatureLen
)2 i)
),2(if
 3(elif
 10(infix
 < ~10 posInCall 6(dot ~4 call 1 len)
)~1,1(stmts
 (yld 6(tupleConstr
 1 genericParam 19(at ~4 call 1 posInCall)
))
)
)
)
)
)
)
)6,2441(const evalMacroLimit . . . 17 +1000),2448(proc
 5 evalMacroCall x . . 19(params
 30,1 PNode 1(param
 module . . 8 PSym .
)15(param idgen . . 7 IdGenerator .)35(param
 g . . 3 ModuleGraph .
)51(param
 templInstCounter . . 18(ref 4 int).
)1,1(param n . . 10 PNode .)4,1(param
 nOrig . . 7 PNode .
)18,1(param sym . . 5 PSym .)
). . 2,5(stmts
 3(call ~3 inc 9(dot
 ~7(dot ~1 g 1 config)1 evalMacroCounter
)),1(if
 3(elif
 26(infix
 > ~18(dot ~7(dot
 ~1 g 1 config
)1 evalMacroCounter)2 evalMacroLimit
)~1,1(stmts
 11(call
 ~11 globalError 2(dot ~1 g 1 config)12(dot
 ~1 n 1 info
)19"macro instantiation too nested"
)
)
)
)4,6(let sl . . . 12(dot
 ~4(dot ~3 sym 1 typ)1 signatureLen
)),7(if
 3(elif
 15(infix
 and ~12(infix > ~3 sl 3(dot
 ~1 n 1 safeLen
))7(infix > ~3 sl 2 +1)
)~1,1(stmts
 11(call
 ~11 globalError 2(dot ~1 g 1 config)12(dot
 ~1 n 1 info
)70(infix
 % ~51"in call \27$\23\27 got $\23, but expected $\23 argument\28s\29" 2(bracketConstr
 ~78,1(dot
 ~1 n 1 renderTree
)~65,1(prefix
 $ 1(par 10(infix
 - ~8(dot ~1 n 1 safeLen)1 +1
))
)~49,1(prefix
 $ 1(par 8(dot
 ~4(dot ~3 sym 1 typ)1 paramsLen
))
)
)
)
)
)
)
)14,11(call
 ~14 setupGlobalCtx 1 module 9 g 12 idgen
)4,12(var c . . . 9(cmd
 ~5 PCtx 1(dot ~1 g 1 vm)
))4,13(let oldMode . . . 11(dot
 ~1 c 1 mode
))7,14(asgn
 ~6(dot ~1 c 1 mode)2 emStaticStmt
)26,15(asgn ~6(dot
 ~19(dot ~1 c 1 comesFromHeuristic)1 line
)2 +0u16)11,16(asgn ~10(dot
 ~1 c 1 callsite
)2 nOrig)19,17(asgn ~18(dot
 ~1 c 1 templInstCounter
)2 templInstCounter)4,18(let start . . . 15(call
 ~7 genProc 1 c 4 sym
))4,20(var
 tos . . . 17(objConstr
 ~11 PStackFrame 4(kv
 ~3 prc 2 sym
)20(kv ~9 comesFrom 2 +0)29(kv ~4 next 2(nil))
)
)4,21(let
 maxSlots . . . 14(dot ~3 sym 1 offset)
)6,22(call
 ~6 newSeq 4(dot ~3 tos 1 slots)12 maxSlots
)4,24(var
 L . . . 5(dot ~1 n 1 safeLen)
),25(if
 3(elif 2(infix == ~2 L 3 +0)8(stmts
 2(asgn ~2 L 2 +1)
))
)13,31(asgn
 ~4(at
 ~6(dot ~3 tos 1 slots)1 +0
)10(objConstr
 ~8 TFullReg 5(kv ~4 kind 2 rkNode)19(kv
 ~4 node 10(call ~8 newNodeI 1 nkEmpty 11(dot
 ~1 n 1 info
))
)
)
)4,34(for
 22(call
 ~10 paramTypes 4(dot ~3 sym 1 typ)
)(unpackIntoFlat
(let i ....)(let 3 param ....)
)~2,1(stmts
 28(asgn
 ~19(at
 ~6(dot ~3 tos 1 slots)15(infix + ~13(infix
 - ~1 i 1 FirstParamAt
)1 +1)
)17(call
 ~15 setupMacroParam 2(at
 ~1 n 15(infix + ~13(infix
 - ~1 i 1 FirstParamAt
)1 +1)
)22 param
)
)
)
)4,37(let gp . . . 12(at
 ~4(dot ~3 sym 1 ast)1 genericParamsPos
))4,38(for
 6(infix ..< ~1 +0 5(dot
 ~2 gp 1 len
))(unpackIntoFlat(let i ....))~2,1(stmts
 4(let idx . . . 27(infix
 + ~14(dot ~4(dot
 ~3 sym 1 typ
)1 signatureLen)2 i
)),1(if
 3(elif
 4(infix < ~4 idx 3(dot
 ~1 n 1 len
))~1,1(stmts
 15(asgn
 ~6(at ~6(dot
 ~3 tos 1 slots
)1 idx)17(call
 ~15 setupMacroParam 2(at
 ~1 n 1 idx
)18(dot
 ~4(dot ~3(at ~2 gp 1 i)1 sym)1 typ
)
)
)
)
),2(else
 2,1(stmts
 3(call ~3 dec 9(dot
 ~7(dot ~1 g 1 config)1 evalMacroCounter
))11,1(asgn ~10(dot
 ~1 c 1 callsite
)2(nil))10,2(call
 ~10 localError 2(dot
 ~1 c 1 config
)12(dot ~1 n 1 info)41(infix
 & ~10(infix
 & ~12"expected " 2(prefix $ 3(dot
 ~2 gp 1 len
))
)~40,1" generic parameter\28s\29"
)
)
)
)
)
)
)7,49(asgn
 ~7 result 27(dot ~15(call
 ~10 rawExecute 1 c 4 start 11 tos
)1 regToNode)
),50(if
 3(elif
 17(infix < ~6(dot
 ~5(dot ~6 result 1 info)1 line
)2 +0)22(stmts 12(asgn
 ~6(dot
 ~6 result 1 info
)3(dot ~1 n 1 info)
))
)
),51(if
 3(elif
 10(call ~10 cyclicTree 1 result)20(stmts
 11(call
 ~11 globalError 2(dot
 ~1 c 1 config
)12(dot ~1 n 1 info)19"macro produced a cyclic tree"
)
)
)
)3,52(call ~3 dec 9(dot
 ~7(dot ~1 g 1 config)1 evalMacroCounter
))11,53(asgn ~10(dot
 ~1 c 1 callsite
)2(nil))7,54(asgn ~6(dot
 ~1 c 1 mode
)2 oldMode)
)
)
)