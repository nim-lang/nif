(.nif24)

(GRAMMAR Module

(COM "This grammar reflects the fact that we produce NASM code.")

(RULE :Directive (global SYMBOL))

(RULE :Code (text SYMBOLDEF (ONE_OR_MANY Instruction)))
(RULE :ExternDecl (extern SYMBOLDEF))

(RULE :DataValue (OR STRINGLITERAL INTLIT UINTLIT FLOATLIT))
(RULE :DataKey SYMBOLDEF (ONE_OR_MANY (OR DataValue (times INTLIT DataValue))))
(RULE :DataDecl (OR
  (db DataKey)
  (dw DataKey)
  (dd DataKey)
  (dq DataKey)
))

(RULE :Data (data (ZERO_OR_MANY DataDecl)))
(RULE :Rodata (rodata (ZERO_OR_MANY DataDecl)))

(RULE :Section (OR Directive ExternDecl Code Data Rodata))

(RULE :Module (stmts (ZERO_OR_MANY Section)))

(RULE :Reg (OR
  (rax) (rbx) (rcx) (rdx) (rsi) (rdi) (rbp) (rsp)
  (r8) (r9) (r10) (r11) (r12) (r13) (r14) (r15)
))

(RULE :FpReg (OR
  (xmm0) (xmm1) (xmm2) (xmm3) (xmm4) (xmm6) (xmm7) (xmm8)
  (xmm9) (xmm10) (xmm11) (xmm12) (xmm13) (xmm14) (xmm15)
))

(COM "We do not model the fact that most mem/mem instructions are invalid")

(RULE :Primary (OR
  Reg FpReg
  SYMBOL
  (rel SYMBOL)
  INTLIT UINTLIT
))

(RULE :Expr (OR
  Primary
  (mem2 Primary Primary)
  (mem3 Primary Primary INTLIT)
  (byteat Primary)
  (wordat Primary)
))

(RULE :Label SYMBOL)

(RULE :Instruction (OR
  (mov Expr Expr)
  (movapd Expr Expr)
  (movsd Expr Expr)
  (lea Expr Expr Expr Expr)
  (add Expr Expr)
  (sub Expr Expr)
  (mul Expr Expr)
  (imul Expr Expr)
  (div Expr Expr)
  (idiv Expr Expr)
  (xor Expr Expr)
  (addsd Expr Expr)
  (subsd Expr Expr)
  (mulsd Expr Expr)
  (divsd Expr Expr)

  (push Expr)
  (pop Expr)
  (inc Expr)
  (dec Expr)
  (neg Expr)
  (cmp Expr Expr)
  (test Expr Expr)
  (call Expr)
  (lab SYMBOLDEF)
  (jmp Label)
  (je Label)
  (jne Label)
  (jz Label)
  (jnz Label)
  (jg Label)
  (jge Label)
  (ja Label)
  (jae Label)
  (nop)
  (ret)
  (syscall)
  (comment (OR IDENT SYMBOL STRINGLITERAL))
))
)
