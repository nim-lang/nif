# Generated by enumgen.nim. DO NOT EDIT!

import "$nim" / compiler / [ast, options]

proc toNifTag*(s: TNodeKind): string =
  case s
  of nkNone: "none"
  of nkEmpty: "empty"
  of nkIdent: "ident"
  of nkSym: "sym"
  of nkType: "onlytype"
  of nkCharLit: "charlit"
  of nkIntLit: "intlit"
  of nkInt8Lit: "int8lit"
  of nkInt16Lit: "int16lit"
  of nkInt32Lit: "int32lit"
  of nkInt64Lit: "int64lit"
  of nkUIntLit: "uintlit"
  of nkUInt8Lit: "uint8lit"
  of nkUInt16Lit: "uint16lit"
  of nkUInt32Lit: "uint32lit"
  of nkUInt64Lit: "uint64lit"
  of nkFloatLit: "floatlit"
  of nkFloat32Lit: "float32lit"
  of nkFloat64Lit: "float64lit"
  of nkFloat128Lit: "float128lit"
  of nkStrLit: "strlit"
  of nkRStrLit: "rstrlit"
  of nkTripleStrLit: "triplestrlit"
  of nkNilLit: "nillit"
  of nkComesFrom: "comesfrom"
  of nkDotCall: "dotcall"
  of nkCommand: "cmd"
  of nkCall: "call"
  of nkCallStrLit: "callstrlit"
  of nkInfix: "infix"
  of nkPrefix: "prefix"
  of nkPostfix: "postfix"
  of nkHiddenCallConv: "hcallconv"
  of nkExprEqExpr: "vv"
  of nkExprColonExpr: "kv"
  of nkIdentDefs: "identdefs"
  of nkVarTuple: "vartuple"
  of nkPar: "par"
  of nkObjConstr: "objconstr"
  of nkCurly: "curly"
  of nkCurlyExpr: "curlyx"
  of nkBracket: "bracket"
  of nkBracketExpr: "bracketx"
  of nkPragmaExpr: "pragmax"
  of nkRange: "range"
  of nkDotExpr: "dotx"
  of nkCheckedFieldExpr: "checkedfieldx"
  of nkDerefExpr: "deref"
  of nkIfExpr: "ifx"
  of nkElifExpr: "elifx"
  of nkElseExpr: "elsex"
  of nkLambda: "lambda"
  of nkDo: "do"
  of nkAccQuoted: "accquoted"
  of nkTableConstr: "tableconstr"
  of nkBind: "bind"
  of nkClosedSymChoice: "closedsymchoice"
  of nkOpenSymChoice: "opensymchoice"
  of nkHiddenStdConv: "hstdconv"
  of nkHiddenSubConv: "hsubconv"
  of nkConv: "conv"
  of nkCast: "cast"
  of nkStaticExpr: "staticx"
  of nkAddr: "addr"
  of nkHiddenAddr: "haddr"
  of nkHiddenDeref: "hderef"
  of nkObjDownConv: "objdownconv"
  of nkObjUpConv: "objupconv"
  of nkChckRangeF: "chckrangef"
  of nkChckRange64: "chckrange64"
  of nkChckRange: "chckrange"
  of nkStringToCString: "stringtocstring"
  of nkCStringToString: "cstringtostring"
  of nkAsgn: "asgn"
  of nkFastAsgn: "fastasgn"
  of nkGenericParams: "genericparams"
  of nkFormalParams: "formalparams"
  of nkOfInherit: "ofinherit"
  of nkImportAs: "importas"
  of nkProcDef: "proc"
  of nkMethodDef: "method"
  of nkConverterDef: "converter"
  of nkMacroDef: "macro"
  of nkTemplateDef: "template"
  of nkIteratorDef: "iterator"
  of nkOfBranch: "of"
  of nkElifBranch: "elif"
  of nkExceptBranch: "except"
  of nkElse: "else"
  of nkAsmStmt: "asm"
  of nkPragma: "pragma"
  of nkPragmaBlock: "pragmablock"
  of nkIfStmt: "if"
  of nkWhenStmt: "when"
  of nkForStmt: "for"
  of nkParForStmt: "parfor"
  of nkWhileStmt: "while"
  of nkCaseStmt: "case"
  of nkTypeSection: "type"
  of nkVarSection: "var"
  of nkLetSection: "let"
  of nkConstSection: "const"
  of nkConstDef: "const0"
  of nkTypeDef: "type0"
  of nkYieldStmt: "yield"
  of nkDefer: "defer"
  of nkTryStmt: "try"
  of nkFinally: "finally"
  of nkRaiseStmt: "raise"
  of nkReturnStmt: "ret"
  of nkBreakStmt: "brk"
  of nkContinueStmt: "continue"
  of nkBlockStmt: "block"
  of nkStaticStmt: "static"
  of nkDiscardStmt: "discard"
  of nkStmtList: "stmtlist"
  of nkImportStmt: "import"
  of nkImportExceptStmt: "importexcept"
  of nkExportStmt: "export"
  of nkExportExceptStmt: "exportexcept"
  of nkFromStmt: "from"
  of nkIncludeStmt: "include"
  of nkBindStmt: "bind0"
  of nkMixinStmt: "mixin"
  of nkUsingStmt: "using"
  of nkCommentStmt: "comment"
  of nkStmtListExpr: "expr"
  of nkBlockExpr: "blockx"
  of nkStmtListType: "stmtlisttype"
  of nkBlockType: "blocktype"
  of nkWith: "with"
  of nkWithout: "without"
  of nkTypeOfExpr: "typeofx"
  of nkObjectTy: "objectty"
  of nkTupleTy: "tuplety"
  of nkTupleClassTy: "tupleclassty"
  of nkTypeClassTy: "typeclassty"
  of nkStaticTy: "staticty"
  of nkRecList: "reclist"
  of nkRecCase: "reccase"
  of nkRecWhen: "recwhen"
  of nkRefTy: "refty"
  of nkPtrTy: "ptrty"
  of nkVarTy: "varty"
  of nkConstTy: "constty"
  of nkOutTy: "outty"
  of nkDistinctTy: "distinctty"
  of nkProcTy: "procty"
  of nkIteratorTy: "iteratorty"
  of nkSinkAsgn: "sinkasgn"
  of nkEnumTy: "enumty"
  of nkEnumFieldDef: "efld"
  of nkArgList: "arglist"
  of nkPattern: "pattern"
  of nkHiddenTryStmt: "htrystmt"
  of nkClosure: "closure"
  of nkGotoState: "gotostate"
  of nkState: "state"
  of nkBreakState: "breakstate"
  of nkFuncDef: "func"
  of nkTupleConstr: "tupleconstr"
  of nkError: "err"
  of nkModuleRef: "moduleref"
  of nkReplayAction: "replayaction"
  of nkNilRodNode: "nilrodnode"
  of nkOpenSym: "opensym"


proc parseNodeKind*(s: string): TNodeKind =
  case s
  of "none": nkNone
  of "empty": nkEmpty
  of "ident": nkIdent
  of "sym": nkSym
  of "onlytype": nkType
  of "charlit": nkCharLit
  of "intlit": nkIntLit
  of "int8lit": nkInt8Lit
  of "int16lit": nkInt16Lit
  of "int32lit": nkInt32Lit
  of "int64lit": nkInt64Lit
  of "uintlit": nkUIntLit
  of "uint8lit": nkUInt8Lit
  of "uint16lit": nkUInt16Lit
  of "uint32lit": nkUInt32Lit
  of "uint64lit": nkUInt64Lit
  of "floatlit": nkFloatLit
  of "float32lit": nkFloat32Lit
  of "float64lit": nkFloat64Lit
  of "float128lit": nkFloat128Lit
  of "strlit": nkStrLit
  of "rstrlit": nkRStrLit
  of "triplestrlit": nkTripleStrLit
  of "nillit": nkNilLit
  of "comesfrom": nkComesFrom
  of "dotcall": nkDotCall
  of "cmd": nkCommand
  of "call": nkCall
  of "callstrlit": nkCallStrLit
  of "infix": nkInfix
  of "prefix": nkPrefix
  of "postfix": nkPostfix
  of "hcallconv": nkHiddenCallConv
  of "vv": nkExprEqExpr
  of "kv": nkExprColonExpr
  of "identdefs": nkIdentDefs
  of "vartuple": nkVarTuple
  of "par": nkPar
  of "objconstr": nkObjConstr
  of "curly": nkCurly
  of "curlyx": nkCurlyExpr
  of "bracket": nkBracket
  of "bracketx": nkBracketExpr
  of "pragmax": nkPragmaExpr
  of "range": nkRange
  of "dotx": nkDotExpr
  of "checkedfieldx": nkCheckedFieldExpr
  of "deref": nkDerefExpr
  of "ifx": nkIfExpr
  of "elifx": nkElifExpr
  of "elsex": nkElseExpr
  of "lambda": nkLambda
  of "do": nkDo
  of "accquoted": nkAccQuoted
  of "tableconstr": nkTableConstr
  of "bind": nkBind
  of "closedsymchoice": nkClosedSymChoice
  of "opensymchoice": nkOpenSymChoice
  of "hstdconv": nkHiddenStdConv
  of "hsubconv": nkHiddenSubConv
  of "conv": nkConv
  of "cast": nkCast
  of "staticx": nkStaticExpr
  of "addr": nkAddr
  of "haddr": nkHiddenAddr
  of "hderef": nkHiddenDeref
  of "objdownconv": nkObjDownConv
  of "objupconv": nkObjUpConv
  of "chckrangef": nkChckRangeF
  of "chckrange64": nkChckRange64
  of "chckrange": nkChckRange
  of "stringtocstring": nkStringToCString
  of "cstringtostring": nkCStringToString
  of "asgn": nkAsgn
  of "fastasgn": nkFastAsgn
  of "genericparams": nkGenericParams
  of "formalparams": nkFormalParams
  of "ofinherit": nkOfInherit
  of "importas": nkImportAs
  of "proc": nkProcDef
  of "method": nkMethodDef
  of "converter": nkConverterDef
  of "macro": nkMacroDef
  of "template": nkTemplateDef
  of "iterator": nkIteratorDef
  of "of": nkOfBranch
  of "elif": nkElifBranch
  of "except": nkExceptBranch
  of "else": nkElse
  of "asm": nkAsmStmt
  of "pragma": nkPragma
  of "pragmablock": nkPragmaBlock
  of "if": nkIfStmt
  of "when": nkWhenStmt
  of "for": nkForStmt
  of "parfor": nkParForStmt
  of "while": nkWhileStmt
  of "case": nkCaseStmt
  of "type": nkTypeSection
  of "var": nkVarSection
  of "let": nkLetSection
  of "const": nkConstSection
  of "const0": nkConstDef
  of "type0": nkTypeDef
  of "yield": nkYieldStmt
  of "defer": nkDefer
  of "try": nkTryStmt
  of "finally": nkFinally
  of "raise": nkRaiseStmt
  of "ret": nkReturnStmt
  of "brk": nkBreakStmt
  of "continue": nkContinueStmt
  of "block": nkBlockStmt
  of "static": nkStaticStmt
  of "discard": nkDiscardStmt
  of "stmtlist": nkStmtList
  of "import": nkImportStmt
  of "importexcept": nkImportExceptStmt
  of "export": nkExportStmt
  of "exportexcept": nkExportExceptStmt
  of "from": nkFromStmt
  of "include": nkIncludeStmt
  of "bind0": nkBindStmt
  of "mixin": nkMixinStmt
  of "using": nkUsingStmt
  of "comment": nkCommentStmt
  of "expr": nkStmtListExpr
  of "blockx": nkBlockExpr
  of "stmtlisttype": nkStmtListType
  of "blocktype": nkBlockType
  of "with": nkWith
  of "without": nkWithout
  of "typeofx": nkTypeOfExpr
  of "objectty": nkObjectTy
  of "tuplety": nkTupleTy
  of "tupleclassty": nkTupleClassTy
  of "typeclassty": nkTypeClassTy
  of "staticty": nkStaticTy
  of "reclist": nkRecList
  of "reccase": nkRecCase
  of "recwhen": nkRecWhen
  of "refty": nkRefTy
  of "ptrty": nkPtrTy
  of "varty": nkVarTy
  of "constty": nkConstTy
  of "outty": nkOutTy
  of "distinctty": nkDistinctTy
  of "procty": nkProcTy
  of "iteratorty": nkIteratorTy
  of "sinkasgn": nkSinkAsgn
  of "enumty": nkEnumTy
  of "efld": nkEnumFieldDef
  of "arglist": nkArgList
  of "pattern": nkPattern
  of "htrystmt": nkHiddenTryStmt
  of "closure": nkClosure
  of "gotostate": nkGotoState
  of "state": nkState
  of "breakstate": nkBreakState
  of "func": nkFuncDef
  of "tupleconstr": nkTupleConstr
  of "err": nkError
  of "moduleref": nkModuleRef
  of "replayaction": nkReplayAction
  of "nilrodnode": nkNilRodNode
  of "opensym": nkOpenSym
  else: nkNone


proc toNifTag*(s: TSymKind): string =
  case s
  of skUnknown: "unknown"
  of skConditional: "conditional"
  of skDynLib: "dynlib"
  of skParam: "param"
  of skGenericParam: "genericparam"
  of skTemp: "temp"
  of skModule: "module"
  of skType: "type"
  of skVar: "var"
  of skLet: "let"
  of skConst: "const"
  of skResult: "result"
  of skProc: "proc"
  of skFunc: "func"
  of skMethod: "method"
  of skIterator: "iterator"
  of skConverter: "converter"
  of skMacro: "macro"
  of skTemplate: "template"
  of skField: "field"
  of skEnumField: "enumfield"
  of skForVar: "forvar"
  of skLabel: "label"
  of skStub: "stub"
  of skPackage: "package"


proc parseSymKind*(s: string): TSymKind =
  case s
  of "unknown": skUnknown
  of "conditional": skConditional
  of "dynlib": skDynLib
  of "param": skParam
  of "genericparam": skGenericParam
  of "temp": skTemp
  of "module": skModule
  of "type": skType
  of "var": skVar
  of "let": skLet
  of "const": skConst
  of "result": skResult
  of "proc": skProc
  of "func": skFunc
  of "method": skMethod
  of "iterator": skIterator
  of "converter": skConverter
  of "macro": skMacro
  of "template": skTemplate
  of "field": skField
  of "enumfield": skEnumField
  of "forvar": skForVar
  of "label": skLabel
  of "stub": skStub
  of "package": skPackage
  else: skUnknown


proc toNifTag*(s: TTypeKind): string =
  case s
  of tyNone: "none"
  of tyBool: "bool"
  of tyChar: "char"
  of tyEmpty: "empty"
  of tyAlias: "alias"
  of tyNil: "nil"
  of tyUntyped: "untyped"
  of tyTyped: "typed"
  of tyTypeDesc: "typedesc"
  of tyGenericInvocation: "ginvoke"
  of tyGenericBody: "gbody"
  of tyGenericInst: "ginst"
  of tyGenericParam: "gparam"
  of tyDistinct: "distinct"
  of tyEnum: "enum"
  of tyOrdinal: "ordinal"
  of tyArray: "array"
  of tyObject: "object"
  of tyTuple: "tuple"
  of tySet: "set"
  of tyRange: "range"
  of tyPtr: "ptr"
  of tyRef: "ref"
  of tyVar: "mut"
  of tySequence: "seq"
  of tyProc: "proctype"
  of tyPointer: "pointer"
  of tyOpenArray: "openarray"
  of tyString: "string"
  of tyCstring: "cstring"
  of tyForward: "forward"
  of tyInt: "int"
  of tyInt8: "int8"
  of tyInt16: "int16"
  of tyInt32: "int32"
  of tyInt64: "int64"
  of tyFloat: "float"
  of tyFloat32: "float32"
  of tyFloat64: "float64"
  of tyFloat128: "float128"
  of tyUInt: "uint"
  of tyUInt8: "uint8"
  of tyUInt16: "uint16"
  of tyUInt32: "uint32"
  of tyUInt64: "uint64"
  of tyOwned: "owned"
  of tySink: "sink"
  of tyLent: "lent"
  of tyVarargs: "varargs"
  of tyUncheckedArray: "uarray"
  of tyError: "error"
  of tyBuiltInTypeClass: "bconcept"
  of tyUserTypeClass: "uconcept"
  of tyUserTypeClassInst: "uconceptinst"
  of tyCompositeTypeClass: "cconcept"
  of tyInferred: "inferred"
  of tyAnd: "and"
  of tyOr: "or"
  of tyNot: "not"
  of tyAnything: "anything"
  of tyStatic: "static"
  of tyFromExpr: "fromx"
  of tyConcept: "concept"
  of tyVoid: "void"
  of tyIterable: "iterable"


proc parseTypeKind*(s: string): TTypeKind =
  case s
  of "none": tyNone
  of "bool": tyBool
  of "char": tyChar
  of "empty": tyEmpty
  of "alias": tyAlias
  of "nil": tyNil
  of "untyped": tyUntyped
  of "typed": tyTyped
  of "typedesc": tyTypeDesc
  of "ginvoke": tyGenericInvocation
  of "gbody": tyGenericBody
  of "ginst": tyGenericInst
  of "gparam": tyGenericParam
  of "distinct": tyDistinct
  of "enum": tyEnum
  of "ordinal": tyOrdinal
  of "array": tyArray
  of "object": tyObject
  of "tuple": tyTuple
  of "set": tySet
  of "range": tyRange
  of "ptr": tyPtr
  of "ref": tyRef
  of "mut": tyVar
  of "seq": tySequence
  of "proctype": tyProc
  of "pointer": tyPointer
  of "openarray": tyOpenArray
  of "string": tyString
  of "cstring": tyCstring
  of "forward": tyForward
  of "int": tyInt
  of "int8": tyInt8
  of "int16": tyInt16
  of "int32": tyInt32
  of "int64": tyInt64
  of "float": tyFloat
  of "float32": tyFloat32
  of "float64": tyFloat64
  of "float128": tyFloat128
  of "uint": tyUInt
  of "uint8": tyUInt8
  of "uint16": tyUInt16
  of "uint32": tyUInt32
  of "uint64": tyUInt64
  of "owned": tyOwned
  of "sink": tySink
  of "lent": tyLent
  of "varargs": tyVarargs
  of "uarray": tyUncheckedArray
  of "error": tyError
  of "bconcept": tyBuiltInTypeClass
  of "uconcept": tyUserTypeClass
  of "uconceptinst": tyUserTypeClassInst
  of "cconcept": tyCompositeTypeClass
  of "inferred": tyInferred
  of "and": tyAnd
  of "or": tyOr
  of "not": tyNot
  of "anything": tyAnything
  of "static": tyStatic
  of "fromx": tyFromExpr
  of "concept": tyConcept
  of "void": tyVoid
  of "iterable": tyIterable
  else: tyNone


proc toNifTag*(s: TLocKind): string =
  case s
  of locNone: "none"
  of locTemp: "temp"
  of locLocalVar: "localvar"
  of locGlobalVar: "globalvar"
  of locParam: "param"
  of locField: "field"
  of locExpr: "expr"
  of locProc: "proc"
  of locData: "data"
  of locCall: "call"
  of locOther: "other"


proc parseLocKind*(s: string): TLocKind =
  case s
  of "none": locNone
  of "temp": locTemp
  of "localvar": locLocalVar
  of "globalvar": locGlobalVar
  of "param": locParam
  of "field": locField
  of "expr": locExpr
  of "proc": locProc
  of "data": locData
  of "call": locCall
  of "other": locOther
  else: locNone


proc toNifTag*(s: TCallingConvention): string =
  case s
  of ccNimCall: "nimcall"
  of ccStdCall: "stdcall"
  of ccCDecl: "cdecl"
  of ccSafeCall: "safecall"
  of ccSysCall: "syscall"
  of ccInline: "inline"
  of ccNoInline: "noinline"
  of ccFastCall: "fastcall"
  of ccThisCall: "thiscall"
  of ccClosure: "closure"
  of ccNoConvention: "noconv"
  of ccMember: "member"


proc parseCallingConvention*(s: string): TCallingConvention =
  case s
  of "nimcall": ccNimCall
  of "stdcall": ccStdCall
  of "cdecl": ccCDecl
  of "safecall": ccSafeCall
  of "syscall": ccSysCall
  of "inline": ccInline
  of "noinline": ccNoInline
  of "fastcall": ccFastCall
  of "thiscall": ccThisCall
  of "closure": ccClosure
  of "noconv": ccNoConvention
  of "member": ccMember
  else: ccNimCall


proc toNifTag*(s: TMagic): string =
  case s
  of mNone: "nonem"
  of mDefined: "defined"
  of mDeclared: "declared"
  of mDeclaredInScope: "declaredinscope"
  of mCompiles: "compiles"
  of mArrGet: "arrget"
  of mArrPut: "arrput"
  of mAsgn: "asgnm"
  of mLow: "low"
  of mHigh: "high"
  of mSizeOf: "sizeof"
  of mAlignOf: "alignof"
  of mOffsetOf: "offsetof"
  of mTypeTrait: "typetrait"
  of mIs: "is"
  of mOf: "ofm"
  of mAddr: "addrm"
  of mType: "typem"
  of mTypeOf: "typeof"
  of mPlugin: "plugin"
  of mEcho: "echo"
  of mShallowCopy: "shallowcopy"
  of mSlurp: "slurp"
  of mStaticExec: "staticexec"
  of mStatic: "staticm"
  of mParseExprToAst: "parseexprtoast"
  of mParseStmtToAst: "parsestmttoast"
  of mExpandToAst: "expandtoast"
  of mQuoteAst: "quoteast"
  of mInc: "inc"
  of mDec: "dec"
  of mOrd: "ord"
  of mNew: "new"
  of mNewFinalize: "newfinalize"
  of mNewSeq: "newseq"
  of mNewSeqOfCap: "newseqofcap"
  of mLengthOpenArray: "lenopenarray"
  of mLengthStr: "lenstr"
  of mLengthArray: "lenarray"
  of mLengthSeq: "lenseq"
  of mIncl: "incl"
  of mExcl: "excl"
  of mCard: "card"
  of mChr: "chr"
  of mGCref: "gcref"
  of mGCunref: "gcunref"
  of mAddI: "add"
  of mSubI: "sub"
  of mMulI: "mul"
  of mDivI: "div"
  of mModI: "mod"
  of mSucc: "succ"
  of mPred: "pred"
  of mAddF64: "addf64"
  of mSubF64: "subf64"
  of mMulF64: "mulf64"
  of mDivF64: "divf64"
  of mShrI: "shr"
  of mShlI: "shl"
  of mAshrI: "ashr"
  of mBitandI: "bitand"
  of mBitorI: "bitor"
  of mBitxorI: "bitxor"
  of mMinI: "min"
  of mMaxI: "max"
  of mAddU: "addu"
  of mSubU: "subu"
  of mMulU: "mulu"
  of mDivU: "divu"
  of mModU: "modu"
  of mEqI: "eq"
  of mLeI: "le"
  of mLtI: "lt"
  of mEqF64: "eqf64"
  of mLeF64: "lef64"
  of mLtF64: "ltf64"
  of mLeU: "leu"
  of mLtU: "ltu"
  of mEqEnum: "eqenum"
  of mLeEnum: "leenum"
  of mLtEnum: "ltenum"
  of mEqCh: "eqch"
  of mLeCh: "lech"
  of mLtCh: "ltch"
  of mEqB: "eqb"
  of mLeB: "leb"
  of mLtB: "ltb"
  of mEqRef: "eqref"
  of mLePtr: "leptr"
  of mLtPtr: "ltptr"
  of mXor: "xor"
  of mEqCString: "eqcstring"
  of mEqProc: "eqproc"
  of mUnaryMinusI: "unaryminus"
  of mUnaryMinusI64: "unaryminusi64"
  of mAbsI: "abs"
  of mNot: "not"
  of mUnaryPlusI: "unaryplus"
  of mBitnotI: "bitnot"
  of mUnaryPlusF64: "unaryplusf64"
  of mUnaryMinusF64: "unaryminusf64"
  of mCharToStr: "chartostr"
  of mBoolToStr: "booltostr"
  of mCStrToStr: "cstrtostr"
  of mStrToStr: "strtostr"
  of mEnumToStr: "enumtostr"
  of mAnd: "and"
  of mOr: "or"
  of mImplies: "implies"
  of mIff: "iff"
  of mExists: "exists"
  of mForall: "forall"
  of mOld: "old"
  of mEqStr: "eqstr"
  of mLeStr: "lestr"
  of mLtStr: "ltstr"
  of mEqSet: "eqset"
  of mLeSet: "leset"
  of mLtSet: "ltset"
  of mMulSet: "mulset"
  of mPlusSet: "plusset"
  of mMinusSet: "minusset"
  of mConStrStr: "constrstr"
  of mSlice: "slice"
  of mDotDot: "dotdot"
  of mFields: "fields"
  of mFieldPairs: "fieldpairs"
  of mOmpParFor: "ompparfor"
  of mAppendStrCh: "addstrch"
  of mAppendStrStr: "addstrstr"
  of mAppendSeqElem: "addseqelem"
  of mInSet: "contains"
  of mRepr: "repr"
  of mExit: "exit"
  of mSetLengthStr: "setlenstr"
  of mSetLengthSeq: "setlenseq"
  of mIsPartOf: "ispartof"
  of mAstToStr: "asttostr"
  of mParallel: "parallel"
  of mSwap: "swap"
  of mIsNil: "isnil"
  of mArrToSeq: "arrtoseq"
  of mOpenArrayToSeq: "openarraytoseq"
  of mNewString: "newstring"
  of mNewStringOfCap: "newstringofcap"
  of mParseBiggestFloat: "parsebiggestfloat"
  of mMove: "move"
  of mEnsureMove: "ensuremove"
  of mWasMoved: "wasmoved"
  of mDup: "dup"
  of mDestroy: "destroy"
  of mTrace: "trace"
  of mDefault: "default"
  of mUnown: "unown"
  of mFinished: "finished"
  of mIsolate: "isolate"
  of mAccessEnv: "accessenv"
  of mAccessTypeField: "accesstypefield"
  of mArray: "array"
  of mOpenArray: "openarray"
  of mRange: "rangem"
  of mSet: "set"
  of mSeq: "seq"
  of mVarargs: "varargs"
  of mRef: "ref"
  of mPtr: "ptr"
  of mVar: "varm"
  of mDistinct: "distinct"
  of mVoid: "void"
  of mTuple: "tuple"
  of mOrdinal: "ordinal"
  of mIterableType: "iterabletype"
  of mInt: "int"
  of mInt8: "int8"
  of mInt16: "int16"
  of mInt32: "int32"
  of mInt64: "int64"
  of mUInt: "uint"
  of mUInt8: "uint8"
  of mUInt16: "uint16"
  of mUInt32: "uint32"
  of mUInt64: "uint64"
  of mFloat: "float"
  of mFloat32: "float32"
  of mFloat64: "float64"
  of mFloat128: "float128"
  of mBool: "bool"
  of mChar: "char"
  of mString: "string"
  of mCstring: "cstring"
  of mPointer: "pointer"
  of mNil: "nil"
  of mExpr: "exprm"
  of mStmt: "stmtm"
  of mTypeDesc: "typedesc"
  of mVoidType: "voidtype"
  of mPNimrodNode: "nimnode"
  of mSpawn: "spawn"
  of mDeepCopy: "deepcopy"
  of mIsMainModule: "ismainmodule"
  of mCompileDate: "compiledate"
  of mCompileTime: "compiletime"
  of mProcCall: "proccall"
  of mCpuEndian: "cpuendian"
  of mHostOS: "hostos"
  of mHostCPU: "hostcpu"
  of mBuildOS: "buildos"
  of mBuildCPU: "buildcpu"
  of mAppType: "apptype"
  of mCompileOption: "compileoption"
  of mCompileOptionArg: "compileoptionarg"
  of mNLen: "nlen"
  of mNChild: "nchild"
  of mNSetChild: "nsetchild"
  of mNAdd: "nadd"
  of mNAddMultiple: "naddmultiple"
  of mNDel: "ndel"
  of mNKind: "nkind"
  of mNSymKind: "nsymkind"
  of mNccValue: "nccvalue"
  of mNccInc: "nccinc"
  of mNcsAdd: "ncsadd"
  of mNcsIncl: "ncsincl"
  of mNcsLen: "ncslen"
  of mNcsAt: "ncsat"
  of mNctPut: "nctput"
  of mNctLen: "nctlen"
  of mNctGet: "nctget"
  of mNctHasNext: "ncthasnext"
  of mNctNext: "nctnext"
  of mNIntVal: "nintval"
  of mNFloatVal: "nfloatval"
  of mNSymbol: "nsymbol"
  of mNIdent: "nident"
  of mNGetType: "ngettype"
  of mNStrVal: "nstrval"
  of mNSetIntVal: "nsetintval"
  of mNSetFloatVal: "nsetfloatval"
  of mNSetSymbol: "nsetsymbol"
  of mNSetIdent: "nsetident"
  of mNSetStrVal: "nsetstrval"
  of mNLineInfo: "nlineinfo"
  of mNNewNimNode: "nnewnimnode"
  of mNCopyNimNode: "ncopynimnode"
  of mNCopyNimTree: "ncopynimtree"
  of mStrToIdent: "strtoident"
  of mNSigHash: "nsighash"
  of mNSizeOf: "nsizeof"
  of mNBindSym: "nbindsym"
  of mNCallSite: "ncallsite"
  of mEqIdent: "eqident"
  of mEqNimrodNode: "eqnimnode"
  of mSameNodeType: "samenodetype"
  of mGetImpl: "getimpl"
  of mNGenSym: "ngensym"
  of mNHint: "nhint"
  of mNWarning: "nwarning"
  of mNError: "nerror"
  of mInstantiationInfo: "instantiationinfo"
  of mGetTypeInfo: "gettypeinfo"
  of mGetTypeInfoV2: "gettypeinfov2"
  of mNimvm: "nimvm"
  of mIntDefine: "intdefine"
  of mStrDefine: "strdefine"
  of mBoolDefine: "booldefine"
  of mGenericDefine: "genericdefine"
  of mRunnableExamples: "runnableexamples"
  of mException: "exception"
  of mBuiltinType: "builtintype"
  of mSymOwner: "symowner"
  of mUncheckedArray: "uncheckedarray"
  of mGetImplTransf: "getimpltransf"
  of mSymIsInstantiationOf: "symisinstantiationof"
  of mNodeId: "nodeid"
  of mPrivateAccess: "privateaccess"
  of mZeroDefault: "zerodefault"


proc parseMagic*(s: string): TMagic =
  case s
  of "nonem": mNone
  of "defined": mDefined
  of "declared": mDeclared
  of "declaredinscope": mDeclaredInScope
  of "compiles": mCompiles
  of "arrget": mArrGet
  of "arrput": mArrPut
  of "asgnm": mAsgn
  of "low": mLow
  of "high": mHigh
  of "sizeof": mSizeOf
  of "alignof": mAlignOf
  of "offsetof": mOffsetOf
  of "typetrait": mTypeTrait
  of "is": mIs
  of "ofm": mOf
  of "addrm": mAddr
  of "typem": mType
  of "typeof": mTypeOf
  of "plugin": mPlugin
  of "echo": mEcho
  of "shallowcopy": mShallowCopy
  of "slurp": mSlurp
  of "staticexec": mStaticExec
  of "staticm": mStatic
  of "parseexprtoast": mParseExprToAst
  of "parsestmttoast": mParseStmtToAst
  of "expandtoast": mExpandToAst
  of "quoteast": mQuoteAst
  of "inc": mInc
  of "dec": mDec
  of "ord": mOrd
  of "new": mNew
  of "newfinalize": mNewFinalize
  of "newseq": mNewSeq
  of "newseqofcap": mNewSeqOfCap
  of "lenopenarray": mLengthOpenArray
  of "lenstr": mLengthStr
  of "lenarray": mLengthArray
  of "lenseq": mLengthSeq
  of "incl": mIncl
  of "excl": mExcl
  of "card": mCard
  of "chr": mChr
  of "gcref": mGCref
  of "gcunref": mGCunref
  of "add": mAddI
  of "sub": mSubI
  of "mul": mMulI
  of "div": mDivI
  of "mod": mModI
  of "succ": mSucc
  of "pred": mPred
  of "addf64": mAddF64
  of "subf64": mSubF64
  of "mulf64": mMulF64
  of "divf64": mDivF64
  of "shr": mShrI
  of "shl": mShlI
  of "ashr": mAshrI
  of "bitand": mBitandI
  of "bitor": mBitorI
  of "bitxor": mBitxorI
  of "min": mMinI
  of "max": mMaxI
  of "addu": mAddU
  of "subu": mSubU
  of "mulu": mMulU
  of "divu": mDivU
  of "modu": mModU
  of "eq": mEqI
  of "le": mLeI
  of "lt": mLtI
  of "eqf64": mEqF64
  of "lef64": mLeF64
  of "ltf64": mLtF64
  of "leu": mLeU
  of "ltu": mLtU
  of "eqenum": mEqEnum
  of "leenum": mLeEnum
  of "ltenum": mLtEnum
  of "eqch": mEqCh
  of "lech": mLeCh
  of "ltch": mLtCh
  of "eqb": mEqB
  of "leb": mLeB
  of "ltb": mLtB
  of "eqref": mEqRef
  of "leptr": mLePtr
  of "ltptr": mLtPtr
  of "xor": mXor
  of "eqcstring": mEqCString
  of "eqproc": mEqProc
  of "unaryminus": mUnaryMinusI
  of "unaryminusi64": mUnaryMinusI64
  of "abs": mAbsI
  of "not": mNot
  of "unaryplus": mUnaryPlusI
  of "bitnot": mBitnotI
  of "unaryplusf64": mUnaryPlusF64
  of "unaryminusf64": mUnaryMinusF64
  of "chartostr": mCharToStr
  of "booltostr": mBoolToStr
  of "cstrtostr": mCStrToStr
  of "strtostr": mStrToStr
  of "enumtostr": mEnumToStr
  of "and": mAnd
  of "or": mOr
  of "implies": mImplies
  of "iff": mIff
  of "exists": mExists
  of "forall": mForall
  of "old": mOld
  of "eqstr": mEqStr
  of "lestr": mLeStr
  of "ltstr": mLtStr
  of "eqset": mEqSet
  of "leset": mLeSet
  of "ltset": mLtSet
  of "mulset": mMulSet
  of "plusset": mPlusSet
  of "minusset": mMinusSet
  of "constrstr": mConStrStr
  of "slice": mSlice
  of "dotdot": mDotDot
  of "fields": mFields
  of "fieldpairs": mFieldPairs
  of "ompparfor": mOmpParFor
  of "addstrch": mAppendStrCh
  of "addstrstr": mAppendStrStr
  of "addseqelem": mAppendSeqElem
  of "contains": mInSet
  of "repr": mRepr
  of "exit": mExit
  of "setlenstr": mSetLengthStr
  of "setlenseq": mSetLengthSeq
  of "ispartof": mIsPartOf
  of "asttostr": mAstToStr
  of "parallel": mParallel
  of "swap": mSwap
  of "isnil": mIsNil
  of "arrtoseq": mArrToSeq
  of "openarraytoseq": mOpenArrayToSeq
  of "newstring": mNewString
  of "newstringofcap": mNewStringOfCap
  of "parsebiggestfloat": mParseBiggestFloat
  of "move": mMove
  of "ensuremove": mEnsureMove
  of "wasmoved": mWasMoved
  of "dup": mDup
  of "destroy": mDestroy
  of "trace": mTrace
  of "default": mDefault
  of "unown": mUnown
  of "finished": mFinished
  of "isolate": mIsolate
  of "accessenv": mAccessEnv
  of "accesstypefield": mAccessTypeField
  of "array": mArray
  of "openarray": mOpenArray
  of "rangem": mRange
  of "set": mSet
  of "seq": mSeq
  of "varargs": mVarargs
  of "ref": mRef
  of "ptr": mPtr
  of "varm": mVar
  of "distinct": mDistinct
  of "void": mVoid
  of "tuple": mTuple
  of "ordinal": mOrdinal
  of "iterabletype": mIterableType
  of "int": mInt
  of "int8": mInt8
  of "int16": mInt16
  of "int32": mInt32
  of "int64": mInt64
  of "uint": mUInt
  of "uint8": mUInt8
  of "uint16": mUInt16
  of "uint32": mUInt32
  of "uint64": mUInt64
  of "float": mFloat
  of "float32": mFloat32
  of "float64": mFloat64
  of "float128": mFloat128
  of "bool": mBool
  of "char": mChar
  of "string": mString
  of "cstring": mCstring
  of "pointer": mPointer
  of "nil": mNil
  of "exprm": mExpr
  of "stmtm": mStmt
  of "typedesc": mTypeDesc
  of "voidtype": mVoidType
  of "nimnode": mPNimrodNode
  of "spawn": mSpawn
  of "deepcopy": mDeepCopy
  of "ismainmodule": mIsMainModule
  of "compiledate": mCompileDate
  of "compiletime": mCompileTime
  of "proccall": mProcCall
  of "cpuendian": mCpuEndian
  of "hostos": mHostOS
  of "hostcpu": mHostCPU
  of "buildos": mBuildOS
  of "buildcpu": mBuildCPU
  of "apptype": mAppType
  of "compileoption": mCompileOption
  of "compileoptionarg": mCompileOptionArg
  of "nlen": mNLen
  of "nchild": mNChild
  of "nsetchild": mNSetChild
  of "nadd": mNAdd
  of "naddmultiple": mNAddMultiple
  of "ndel": mNDel
  of "nkind": mNKind
  of "nsymkind": mNSymKind
  of "nccvalue": mNccValue
  of "nccinc": mNccInc
  of "ncsadd": mNcsAdd
  of "ncsincl": mNcsIncl
  of "ncslen": mNcsLen
  of "ncsat": mNcsAt
  of "nctput": mNctPut
  of "nctlen": mNctLen
  of "nctget": mNctGet
  of "ncthasnext": mNctHasNext
  of "nctnext": mNctNext
  of "nintval": mNIntVal
  of "nfloatval": mNFloatVal
  of "nsymbol": mNSymbol
  of "nident": mNIdent
  of "ngettype": mNGetType
  of "nstrval": mNStrVal
  of "nsetintval": mNSetIntVal
  of "nsetfloatval": mNSetFloatVal
  of "nsetsymbol": mNSetSymbol
  of "nsetident": mNSetIdent
  of "nsetstrval": mNSetStrVal
  of "nlineinfo": mNLineInfo
  of "nnewnimnode": mNNewNimNode
  of "ncopynimnode": mNCopyNimNode
  of "ncopynimtree": mNCopyNimTree
  of "strtoident": mStrToIdent
  of "nsighash": mNSigHash
  of "nsizeof": mNSizeOf
  of "nbindsym": mNBindSym
  of "ncallsite": mNCallSite
  of "eqident": mEqIdent
  of "eqnimnode": mEqNimrodNode
  of "samenodetype": mSameNodeType
  of "getimpl": mGetImpl
  of "ngensym": mNGenSym
  of "nhint": mNHint
  of "nwarning": mNWarning
  of "nerror": mNError
  of "instantiationinfo": mInstantiationInfo
  of "gettypeinfo": mGetTypeInfo
  of "gettypeinfov2": mGetTypeInfoV2
  of "nimvm": mNimvm
  of "intdefine": mIntDefine
  of "strdefine": mStrDefine
  of "booldefine": mBoolDefine
  of "genericdefine": mGenericDefine
  of "runnableexamples": mRunnableExamples
  of "exception": mException
  of "builtintype": mBuiltinType
  of "symowner": mSymOwner
  of "uncheckedarray": mUncheckedArray
  of "getimpltransf": mGetImplTransf
  of "symisinstantiationof": mSymIsInstantiationOf
  of "nodeid": mNodeId
  of "privateaccess": mPrivateAccess
  of "zerodefault": mZeroDefault
  else: mNone


proc genFlags*(s: set[TSymFlag]; dest: var string) =
  for e in s:
    case e
    of sfUsed: dest.add "u"
    of sfExported: dest.add "e"
    of sfFromGeneric: dest.add "f"
    of sfGlobal: dest.add "g"
    of sfForward: dest.add "f0"
    of sfWasForwarded: dest.add "w"
    of sfImportc: dest.add "i"
    of sfExportc: dest.add "e0"
    of sfMangleCpp: dest.add "m"
    of sfVolatile: dest.add "v"
    of sfRegister: dest.add "r"
    of sfPure: dest.add "p"
    of sfNoSideEffect: dest.add "n"
    of sfSideEffect: dest.add "s"
    of sfMainModule: dest.add "m0"
    of sfSystemModule: dest.add "s0"
    of sfNoReturn: dest.add "n0"
    of sfAddrTaken: dest.add "a"
    of sfCompilerProc: dest.add "c"
    of sfEscapes: dest.add "e1"
    of sfDiscriminant: dest.add "d"
    of sfRequiresInit: dest.add "r0"
    of sfDeprecated: dest.add "d0"
    of sfExplain: dest.add "e2"
    of sfError: dest.add "e3"
    of sfShadowed: dest.add "s1"
    of sfThread: dest.add "t"
    of sfCppNonPod: dest.add "c0"
    of sfCompileTime: dest.add "c1"
    of sfConstructor: dest.add "c2"
    of sfDispatcher: dest.add "d1"
    of sfBorrow: dest.add "b"
    of sfInfixCall: dest.add "i0"
    of sfNamedParamCall: dest.add "n1"
    of sfDiscardable: dest.add "d2"
    of sfOverridden: dest.add "o"
    of sfCallsite: dest.add "c3"
    of sfGenSym: dest.add "g0"
    of sfNonReloadable: dest.add "n2"
    of sfGeneratedOp: dest.add "g1"
    of sfTemplateParam: dest.add "t0"
    of sfCursor: dest.add "c4"
    of sfInjectDestructors: dest.add "i1"
    of sfNeverRaises: dest.add "n3"
    of sfSystemRaisesDefect: dest.add "s2"
    of sfUsedInFinallyOrExcept: dest.add "u0"
    of sfSingleUsedTemp: dest.add "s3"
    of sfNoalias: dest.add "n4"
    of sfEffectsDelayed: dest.add "e4"
    of sfGeneratedType: dest.add "g2"
    of sfVirtual: dest.add "v0"
    of sfByCopy: dest.add "b0"
    of sfMember: dest.add "m1"
    of sfCodegenDecl: dest.add "c5"
    of sfWasGenSym: dest.add "w0"
    of sfForceLift: dest.add "l"
    of sfDirty: dest.add "d3"
    of sfCustomPragma: dest.add "c6"
    of sfBase: dest.add "b1"
    of sfGoto: dest.add "g3"
    of sfAnon: dest.add "a0"
    of sfAllUntyped: dest.add "a1"
    of sfTemplateRedefinition: dest.add "t1"


proc parseSymFlags*(s: string): set[TSymFlag] =
  result = {}
  var i = 0
  while i < s.len:
    case s[i]
    of 'a':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfAnon
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfAllUntyped
        inc i
      else: result.incl sfAddrTaken
    of 'b':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfByCopy
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfBase
        inc i
      else: result.incl sfBorrow
    of 'c':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfCppNonPod
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfCompileTime
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfConstructor
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfCallsite
        inc i
      elif i+1 < s.len and s[i+1] == '4':
        result.incl sfCursor
        inc i
      elif i+1 < s.len and s[i+1] == '5':
        result.incl sfCodegenDecl
        inc i
      elif i+1 < s.len and s[i+1] == '6':
        result.incl sfCustomPragma
        inc i
      else: result.incl sfCompilerProc
    of 'd':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfDeprecated
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfDispatcher
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfDiscardable
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfDirty
        inc i
      else: result.incl sfDiscriminant
    of 'e':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfExportc
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfEscapes
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfExplain
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfError
        inc i
      elif i+1 < s.len and s[i+1] == '4':
        result.incl sfEffectsDelayed
        inc i
      else: result.incl sfExported
    of 'f':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfForward
        inc i
      else: result.incl sfFromGeneric
    of 'g':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfGenSym
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfGeneratedOp
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfGeneratedType
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfGoto
        inc i
      else: result.incl sfGlobal
    of 'i':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfInfixCall
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfInjectDestructors
        inc i
      else: result.incl sfImportc
    of 'l': result.incl sfForceLift
    of 'm':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfMainModule
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfMember
        inc i
      else: result.incl sfMangleCpp
    of 'n':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfNoReturn
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfNamedParamCall
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfNonReloadable
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfNeverRaises
        inc i
      elif i+1 < s.len and s[i+1] == '4':
        result.incl sfNoalias
        inc i
      else: result.incl sfNoSideEffect
    of 'o': result.incl sfOverridden
    of 'p': result.incl sfPure
    of 'r':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfRequiresInit
        inc i
      else: result.incl sfRegister
    of 's':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfSystemModule
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfShadowed
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl sfSystemRaisesDefect
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl sfSingleUsedTemp
        inc i
      else: result.incl sfSideEffect
    of 't':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfTemplateParam
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl sfTemplateRedefinition
        inc i
      else: result.incl sfThread
    of 'u':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfUsedInFinallyOrExcept
        inc i
      else: result.incl sfUsed
    of 'v':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfVirtual
        inc i
      else: result.incl sfVolatile
    of 'w':
      if i+1 < s.len and s[i+1] == '0':
        result.incl sfWasGenSym
        inc i
      else: result.incl sfWasForwarded
    else: discard
    inc i

proc genFlags*(s: set[TNodeFlag]; dest: var string) =
  for e in s:
    case e
    of nfNone: dest.add "n"
    of nfBase2: dest.add "b"
    of nfBase8: dest.add "b0"
    of nfBase16: dest.add "b1"
    of nfAllConst: dest.add "a"
    of nfTransf: dest.add "t"
    of nfNoRewrite: dest.add "r"
    of nfSem: dest.add "s"
    of nfLL: dest.add "l"
    of nfDotField: dest.add "d"
    of nfDotSetter: dest.add "d0"
    of nfExplicitCall: dest.add "e"
    of nfExprCall: dest.add "c"
    of nfIsRef: dest.add "i"
    of nfIsPtr: dest.add "p"
    of nfPreventCg: dest.add "p0"
    of nfBlockArg: dest.add "b2"
    of nfFromTemplate: dest.add "f"
    of nfDefaultParam: dest.add "d1"
    of nfDefaultRefsParam: dest.add "d2"
    of nfExecuteOnReload: dest.add "o"
    of nfLastRead: dest.add "l0"
    of nfFirstWrite: dest.add "w"
    of nfHasComment: dest.add "h"
    of nfSkipFieldChecking: dest.add "s0"
    of nfDisabledOpenSym: dest.add "d3"


proc parseNodeFlags*(s: string): set[TNodeFlag] =
  result = {}
  var i = 0
  while i < s.len:
    case s[i]
    of 'a': result.incl nfAllConst
    of 'b':
      if i+1 < s.len and s[i+1] == '0':
        result.incl nfBase8
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl nfBase16
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl nfBlockArg
        inc i
      else: result.incl nfBase2
    of 'c': result.incl nfExprCall
    of 'd':
      if i+1 < s.len and s[i+1] == '0':
        result.incl nfDotSetter
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl nfDefaultParam
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl nfDefaultRefsParam
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl nfDisabledOpenSym
        inc i
      else: result.incl nfDotField
    of 'e': result.incl nfExplicitCall
    of 'f': result.incl nfFromTemplate
    of 'h': result.incl nfHasComment
    of 'i': result.incl nfIsRef
    of 'l':
      if i+1 < s.len and s[i+1] == '0':
        result.incl nfLastRead
        inc i
      else: result.incl nfLL
    of 'n': result.incl nfNone
    of 'o': result.incl nfExecuteOnReload
    of 'p':
      if i+1 < s.len and s[i+1] == '0':
        result.incl nfPreventCg
        inc i
      else: result.incl nfIsPtr
    of 'r': result.incl nfNoRewrite
    of 's':
      if i+1 < s.len and s[i+1] == '0':
        result.incl nfSkipFieldChecking
        inc i
      else: result.incl nfSem
    of 't': result.incl nfTransf
    of 'w': result.incl nfFirstWrite
    else: discard
    inc i

proc genFlags*(s: set[TTypeFlag]; dest: var string) =
  for e in s:
    case e
    of tfVarargs: dest.add "v"
    of tfNoSideEffect: dest.add "n"
    of tfFinal: dest.add "f"
    of tfInheritable: dest.add "i"
    of tfHasOwned: dest.add "h"
    of tfEnumHasHoles: dest.add "e"
    of tfShallow: dest.add "s"
    of tfThread: dest.add "t"
    of tfFromGeneric: dest.add "g"
    of tfUnresolved: dest.add "u"
    of tfResolved: dest.add "r"
    of tfRetType: dest.add "r0"
    of tfCapturesEnv: dest.add "c"
    of tfByCopy: dest.add "b"
    of tfByRef: dest.add "b0"
    of tfIterator: dest.add "i0"
    of tfPartial: dest.add "p"
    of tfNotNil: dest.add "n0"
    of tfRequiresInit: dest.add "r1"
    of tfNeedsFullInit: dest.add "n1"
    of tfVarIsPtr: dest.add "v0"
    of tfHasMeta: dest.add "m"
    of tfHasGCedMem: dest.add "h0"
    of tfPacked: dest.add "p0"
    of tfHasStatic: dest.add "h1"
    of tfGenericTypeParam: dest.add "g0"
    of tfImplicitTypeParam: dest.add "i1"
    of tfInferrableStatic: dest.add "i2"
    of tfConceptMatchedTypeSym: dest.add "c0"
    of tfExplicit: dest.add "e0"
    of tfWildcard: dest.add "w"
    of tfHasAsgn: dest.add "a"
    of tfBorrowDot: dest.add "d"
    of tfTriggersCompileTime: dest.add "t0"
    of tfRefsAnonObj: dest.add "o"
    of tfCovariant: dest.add "c1"
    of tfWeakCovariant: dest.add "w0"
    of tfContravariant: dest.add "c2"
    of tfCheckedForDestructor: dest.add "c3"
    of tfAcyclic: dest.add "a0"
    of tfIncompleteStruct: dest.add "i3"
    of tfCompleteStruct: dest.add "c4"
    of tfExplicitCallConv: dest.add "e1"
    of tfIsConstructor: dest.add "i4"
    of tfEffectSystemWorkaround: dest.add "e2"
    of tfIsOutParam: dest.add "i5"
    of tfSendable: dest.add "s0"
    of tfImplicitStatic: dest.add "i6"


proc parseTypeFlags*(s: string): set[TTypeFlag] =
  result = {}
  var i = 0
  while i < s.len:
    case s[i]
    of 'a':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfAcyclic
        inc i
      else: result.incl tfHasAsgn
    of 'b':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfByRef
        inc i
      else: result.incl tfByCopy
    of 'c':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfConceptMatchedTypeSym
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfCovariant
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl tfContravariant
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl tfCheckedForDestructor
        inc i
      elif i+1 < s.len and s[i+1] == '4':
        result.incl tfCompleteStruct
        inc i
      else: result.incl tfCapturesEnv
    of 'd': result.incl tfBorrowDot
    of 'e':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfExplicit
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfExplicitCallConv
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl tfEffectSystemWorkaround
        inc i
      else: result.incl tfEnumHasHoles
    of 'f': result.incl tfFinal
    of 'g':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfGenericTypeParam
        inc i
      else: result.incl tfFromGeneric
    of 'h':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfHasGCedMem
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfHasStatic
        inc i
      else: result.incl tfHasOwned
    of 'i':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfIterator
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfImplicitTypeParam
        inc i
      elif i+1 < s.len and s[i+1] == '2':
        result.incl tfInferrableStatic
        inc i
      elif i+1 < s.len and s[i+1] == '3':
        result.incl tfIncompleteStruct
        inc i
      elif i+1 < s.len and s[i+1] == '4':
        result.incl tfIsConstructor
        inc i
      elif i+1 < s.len and s[i+1] == '5':
        result.incl tfIsOutParam
        inc i
      elif i+1 < s.len and s[i+1] == '6':
        result.incl tfImplicitStatic
        inc i
      else: result.incl tfInheritable
    of 'm': result.incl tfHasMeta
    of 'n':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfNotNil
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfNeedsFullInit
        inc i
      else: result.incl tfNoSideEffect
    of 'o': result.incl tfRefsAnonObj
    of 'p':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfPacked
        inc i
      else: result.incl tfPartial
    of 'r':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfRetType
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl tfRequiresInit
        inc i
      else: result.incl tfResolved
    of 's':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfSendable
        inc i
      else: result.incl tfShallow
    of 't':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfTriggersCompileTime
        inc i
      else: result.incl tfThread
    of 'u': result.incl tfUnresolved
    of 'v':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfVarIsPtr
        inc i
      else: result.incl tfVarargs
    of 'w':
      if i+1 < s.len and s[i+1] == '0':
        result.incl tfWeakCovariant
        inc i
      else: result.incl tfWildcard
    else: discard
    inc i

proc genFlags*(s: set[TLocFlag]; dest: var string) =
  for e in s:
    case e
    of lfIndirect: dest.add "i"
    of lfNoDeepCopy: dest.add "n"
    of lfNoDecl: dest.add "d"
    of lfDynamicLib: dest.add "l"
    of lfExportLib: dest.add "e"
    of lfHeader: dest.add "h"
    of lfImportCompilerProc: dest.add "c"
    of lfSingleUse: dest.add "s"
    of lfEnforceDeref: dest.add "e0"
    of lfPrepareForMutation: dest.add "p"


proc parseLocFlags*(s: string): set[TLocFlag] =
  result = {}
  var i = 0
  while i < s.len:
    case s[i]
    of 'c': result.incl lfImportCompilerProc
    of 'd': result.incl lfNoDecl
    of 'e':
      if i+1 < s.len and s[i+1] == '0':
        result.incl lfEnforceDeref
        inc i
      else: result.incl lfExportLib
    of 'h': result.incl lfHeader
    of 'i': result.incl lfIndirect
    of 'l': result.incl lfDynamicLib
    of 'n': result.incl lfNoDeepCopy
    of 'p': result.incl lfPrepareForMutation
    of 's': result.incl lfSingleUse
    else: discard
    inc i

proc genFlags*(s: set[TOption]; dest: var string) =
  for e in s:
    case e
    of optNone: dest.add "n"
    of optObjCheck: dest.add "o"
    of optFieldCheck: dest.add "f"
    of optRangeCheck: dest.add "r"
    of optBoundsCheck: dest.add "b"
    of optOverflowCheck: dest.add "c"
    of optRefCheck: dest.add "r0"
    of optNaNCheck: dest.add "n0"
    of optInfCheck: dest.add "i"
    of optStaticBoundsCheck: dest.add "s"
    of optStyleCheck: dest.add "s0"
    of optAssert: dest.add "a"
    of optLineDir: dest.add "l"
    of optWarns: dest.add "w"
    of optHints: dest.add "h"
    of optOptimizeSpeed: dest.add "o0"
    of optOptimizeSize: dest.add "o1"
    of optStackTrace: dest.add "t"
    of optStackTraceMsgs: dest.add "m"
    of optLineTrace: dest.add "l0"
    of optByRef: dest.add "b0"
    of optProfiler: dest.add "p"
    of optImplicitStatic: dest.add "i0"
    of optTrMacros: dest.add "t0"
    of optMemTracker: dest.add "m0"
    of optSinkInference: dest.add "s1"
    of optCursorInference: dest.add "c0"
    of optImportHidden: dest.add "i1"
    of optQuirky: dest.add "q"


proc parseOptions*(s: string): set[TOption] =
  result = {}
  var i = 0
  while i < s.len:
    case s[i]
    of 'a': result.incl optAssert
    of 'b':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optByRef
        inc i
      else: result.incl optBoundsCheck
    of 'c':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optCursorInference
        inc i
      else: result.incl optOverflowCheck
    of 'f': result.incl optFieldCheck
    of 'h': result.incl optHints
    of 'i':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optImplicitStatic
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl optImportHidden
        inc i
      else: result.incl optInfCheck
    of 'l':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optLineTrace
        inc i
      else: result.incl optLineDir
    of 'm':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optMemTracker
        inc i
      else: result.incl optStackTraceMsgs
    of 'n':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optNaNCheck
        inc i
      else: result.incl optNone
    of 'o':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optOptimizeSpeed
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl optOptimizeSize
        inc i
      else: result.incl optObjCheck
    of 'p': result.incl optProfiler
    of 'q': result.incl optQuirky
    of 'r':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optRefCheck
        inc i
      else: result.incl optRangeCheck
    of 's':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optStyleCheck
        inc i
      elif i+1 < s.len and s[i+1] == '1':
        result.incl optSinkInference
        inc i
      else: result.incl optStaticBoundsCheck
    of 't':
      if i+1 < s.len and s[i+1] == '0':
        result.incl optTrMacros
        inc i
      else: result.incl optStackTrace
    of 'w': result.incl optWarns
    else: discard
    inc i

